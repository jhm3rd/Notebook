<!DOCTYPE html>
<html lang="en">
<head>
	<title>HP-25 Calculator</title>
	<meta charset="utf-8">
	<meta name="keywords" content="calculator,emulator,Hewlett,Packard, HP-25"/>
	<meta name="description" content="Emulation of an HP-25 Calculator"/>

<style>
body {
	font-family: "Gill Sans", Tahoma, Arial, Geneva, sans-serif;
}
div {
    width: 306px;
    height: 567px;
    border: 1px solid black;
    text-align: center;
}

.history {
	width: 900px;
}

input[type='text'] {
	color: red;
	font-size: 12pt;
	font-family: "Digital 7 Mono", Lucida Console, Monaco, monospace;
	font-variant: italic;
}

.small {
	font-size: 8pt;
}


</style>

<script type="text/javascript">
<!--
// Will make four major changes vs HP-25.html. The first is a more full featured tool 
// for managing the accumulating information. This consists of an object holding 
// the parts of the entry and the functions for manipulating it.

// The second is moving the timing for 
// converting this accumulating info into a number in the X stack register. This has 
// been moved to the time of using it, either upon Enter or a function.

// The third is implementing a recording feature for composing a program.

// Might as well also ensure that the stack lifts at the right times and that LastX is 
// used at the right times. See page 111 of the manual for the details.

// Will also consider a fifth major change: moving the globals into an IIFE to limit 
// the number of global items and to enhance access.

// And yet, one more to consider. Wrap the oneNum and twoNum functions in overarching  
// functions to localize them and minimize the number of global functions. Also wrap 
// the entirety in the one function called by the calculator except for the needed globals.

// A bug is seen on repeated calculations and its source is unclear. I believe it in some 
// way involves the flags. Consequently, I will implement a history function as an 
// array that will capture key clicks and record the key as well as all flag 
// states at that time. This array will be written to the page after each functional 
// and number key press.

let History = [];

leftPad = function(str, numFlags = 21){
    return `${'0'.repeat(Math.max(numFlags - str.length,0))}${str}`;
}

function addHistoryEvent(keyPressed)
{
	const flagStr = Flags.toString(2);
	const flagString = leftPad(flagStr);
	const expFlgStr = stretchIt(flagString);
	const event = `${keyPressed}: ${X} ${Y} ${Z} ${T} ${LastX}; ${expFlgStr}`;
	History[History.length] = event;
}

function stretchIt(str)		// given flag string add spaces to match flag names in table
							// 000000010100000000001 =>
							// 00 0 00 001 0 100 0 0 0 0 0 0 0 01
{
	const newStr = `${str.slice(0,2)} ${str.slice(2,3)} ${str.slice(3,5)} ${str.slice(5,8)} ${str.slice(8,9)} ${str.slice(9,12)} ${str.slice(12,13)} ${str.slice(13,14)} ${str.slice(14,15)} ${str.slice(15,16)} ${str.slice(16,17)} ${str.slice(17,18)} ${str.slice(18,19)} ${str.slice(19)}`;
	return newStr;
}

function showHistory(){
	const histDiv = document.querySelector(".history");
	
	let hist = "";
	let len = History.length

	for (let i = 0; i < History.length; i++)
	{
		hist = hist + `<tr><td>${History[i]}</td></tr>`;
	}

	const histTable = `<table>
		<tbody>
			<tr>
				<td class="small">K X Y Z T LtX; Rs Go S+ R S GRD De -- FES -g- -f- Ee NP LX Nn E Pg P</td>
				
			</tr>
			${hist}
		</tbody>
	</table>`
	
	if (ShowHideState){
		histDiv.innerHTML = '';
		ShowHideState= !ShowHideState;
	}
	else {
		histDiv.innerHTML = histTable;
		ShowHideState= !ShowHideState;
	}
}


// --------------------------------------------------------------------------- //
// Global entry info accumulator

// Create the object (not using a reference type since only one is ever needed)

let DataAccum =
{
	sign: " ",							// initialize with a space
	mantissa: "",
	expSign: " ",						// also initialize with space
	exp: "",
	
	// The four functions to set these properties.
	
	setSign: function(pm) {				// pm is the char to replace the space
		this.sign = pm;
	},
	
	setMantissa: function(digit) {		// digit is new digit to be added to mantissa
		this.mantissa = this.mantissa + digit;
	},
	
	// the following two setters need to have range checking built in.
	// Mantissa is too big >= 1,000,000,000.
	// Mantissa is too small first non-zero digit occurs after first eight digits,
	// e.g. 0000.000025 cannot have an exponent.
	
	tooBig: function() {			// returns boolean: true if too big for exponent
		return (parseFloat(this.mantissa) >= 1000000000) ? true : false;
	},
	
	tooLittle: function() {			// returns boolean; true if too small for exponent
		const mant = this.mantissa;
		const len = mant.length;
		if (len > 8) {				// must have at least 8 zeros before 1st sig fig
			let i = 0;
			for (i = 0; i <= len-1; i++) {	// check each char to see if it is zero
				if (mant.charAt(i) == "0" || mant.charAt(i) == ".") {}
				else { break; }
			}
			return (i >= 8) ? true : false;
		} 
	},
	
	setExpSign: function(pm) {
		if (!this.tooBig() && !this.tooLittle()) {
			this.expSign = pm;
		}
		else {
			errorCond("Number is out of range for an exponent");
		}
	},
	setExp: function(digit) {
		if (!this.tooBig() && !this.tooLittle()) {
			this.exp = this.exp + digit;
			if (this.mantissa == "") {
				this.mantissa = "1";
			}
		}
		else {
			errorCond("Number is out of range for an exponent");
		}
	},
	
	// the four functions to get these properties
	
	getSign: function() {
		return this.sign;
	},
	getMantissa: function() {
		return this.mantissa;
	},
	getExpSign: function() {
		return this.expSign;
	},
	getExp: function() {
		return this.exp;
	},
	
	// Other useful functions
	
	convertToNum: function() {				// four property strings to a number
		let ourNum = parseFloat(this.mantissa);
		if (this.sign == "-") {				// if we have a negative sign
			ourNum = ourNum * -1;
		}
		if (this.exp != "") {				// if we have an exponent
			let exponent = parseInt(this.exp);
			if (this.expSign == "-") {		// if we have a sign for the exponent
				exponent = exponent * -1;
			}
			ourNum = ourNum * 10 ** exponent;
		}
		return ourNum;
	},
	
	negativeNum: function() {				// returns  true for a negative number
		return (this.sign == "-") ? true : false;
	},
	
	negativeExp: function() {				// returns  true for a negative exponent
		return (this.expSign == "-") ? true : false;
	},
	
	accumulatedData: function() {			// returns a displayable number
		return `${this.getSign()}${this.getMantissa()}${this.getExpSign()}${this.getExp()}`;
	},
	
	clearData: function() {
		this.sign = " ";
		this.mantissa = "";
		this.expSign = " ";
		this.exp = "";
	}
}

function updateDisp(accumulating){		// accumulating is boolean

	let numStr = "";					// displayed number is not rounded during entry
	if (accumulating){					// display updates during the entry process
		display(DataAccum.accumulatedData());
		if (getFlag('nPushX')) {			// first new digit so stack lifts
			pushX(DataAccum.convertToNum());
			setFlag('nPushX');				// set to false as we have already pushed
		}
		else {
			X = DataAccum.convertToNum();	// update X with every number entered
		}
	}
	else {
		if (getFlag('eng')){				// engineering format
			numStr = dispEng(X);			// returns X formatted in ENG n
		}
		else if (getFlag('sci')){			// scientific format
			numStr = dispSci(X);			// returns X formatted in SCI n
		}
		else {								// fixed format, the default
			numStr = dispFix(X);			// returns X formatted in FIX n
		}
		display(numStr);
	}
}


// Global flags

//  21 flags at this point
//	power, pgrm, error, newNum, lastX, sci, eng, fix, deg, rad, grad, f, g, store, 
//  recall, goto, r/s, dec, eex, sig plus, nPushX

//	Will replace the FlagArray with a 32 bit number in base 2 and use masks to determine 
//		whether a particular flag is set. This is significantly (32x) faster than 
//		other ways of checking flags.
//	To do this, global variable Flags is needed as well as masks for each bit or group of 
//		bits that needs to be checked. Functions will be created for checking and setting 
//		bits. The same flags as above will be used, but in a different order:
//		power, pgrm, error, newNum, lastX, nPushX, eex, f, g, sci, eng, fix, dec, deg, 
//		rad, grad, store, recall, sigPlus, goto, r/s.

let Flags = 0;			//	00000000000000000000000000000000	global stores all flags

//	All flags are off initially.

let PowerM = 1;			//	00000000000000000000000000000001	power on/off
let PrgmM = 2;			//	00000000000000000000000000000010	program record
let ErrorM = 4;			//	00000000000000000000000000000100	error condition
let NewNumM = 8;		//	00000000000000000000000000001000	next char is new number
let LastXM = 16;		//	00000000000000000000000000010000	save X in LastX register
let NPushXM = 32;		//	00000000000000000000000000100000	next operation will push stack
let EexM = 64;			//	00000000000000000000000001000000	next char goes into exponent
let FM = 128;			//	00000000000000000000000010000000	f key operation
let GM = 256;			//	00000000000000000000000100000000	g key operation
let SciM = 512;			//	00000000000000000000001000000000	scientific notation
let EngM = 1024;		//	00000000000000000000010000000000	engineering notation
let FixM = 2048;		//	00000000000000000000100000000000	fixed notation
let DecM = 4096;		//	00000000000000000001000000000000	waiting for num of decimals to show
let DegM = 8192;		//	00000000000000000010000000000000	calculate in degrees
let RadM = 16384;		//	00000000000000000100000000000000	calculate in radians
let GradM = 32768;		//	00000000000000001000000000000000	calculate in grads
let StoreM = 65536;		//	00000000000000010000000000000000	next number is register for storage
let RecallM = 131072;	//	00000000000000100000000000000000	next number is register to recall
let SigPlusM = 262144;	//	00000000000001000000000000000000	next number is sigma plus
let GoToM = 524288;		//	00000000000010000000000000000000	next number is program step to move to
let RSM = 1048576;		//	00000000000100000000000000000000	runs or stops the program

//	Flags are set by ORing them with a bitmask.

function flagOn(mask)
{
	Flags |= mask;
}

//	Flags are cleared by ANDing them with a mask. The required mask can be obtained by 
//		NOTing one of the primitive bitmasks from above.

function flagOff(mask)
{
	mask = ~mask;
	Flags &= mask;
}

//	Flags are checked by ANDing them with a bitmask.

function flagIsOn(mask)
{
	let result = false;
	(Flags & mask) ? result = true : result = false;
	return result;
}

let FlagArray = [];

//  Error conditions:
//  1/0 (done), y^x when Y<=0 (done), sqrt(x) when x<0 (done), log x when x<=0 (done), ln x when x<=0 (done), sin^-1 x 
//  when |x|>1 (done), cos^-1 x when |x|>1 (done), STO / when x=0, x bar when n<=0 (done), and s when n<=1 (done)

// Global settings

let NumDecimals = 0;	//  The number of mantissa elements displayed in given format

// Global registers

// Storage stack

let X=0, Y=0, Z=0, T=0;

let LastX = 0;

// Storage registers

let R07 = [];

// Program registers

let PgrmMem = [];
let PgrmPos = 0;

// storage for +, -, *, or / after STO

let storeFxn = '';

// debug global

let ShowHideState = false;

// end of Global variables

// initialization functions

function initFlagArray(){
	FlagArray = [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false];
}

function initNumDecimals(){
	NumDecimals = 2;
}

function initStack(){
	X = 0;
	Y = 0;
	Z = 0;
	T = 0;
	LastX = 0;
}

function initReg(){
	R07 = [0,0,0,0,0,0,0,0];
}

function initPrgmMem(){		// all mem cells filled with GTO 00 except 00, which has auto stop command
	PgrmMem = ['','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00'];
}

function initPgrmPos(){
	PgrmPos = 0;
}

function setFlag(flag){
	switch (flag)
	{
		case 'power':							// on/off state for calculator
			FlagArray[0] = !FlagArray[0];
			break;
		case 'pgrm':							// need to record program
			FlagArray[1] = !FlagArray[1];
			break;
		case 'error':							// need to clear error
			FlagArray[2] = !FlagArray[2];
			break;
		case 'newNum':							// starting a new number
			FlagArray[3] = !FlagArray[3];
			break;
		case 'lastX':							// need to update LastX
			FlagArray[4] = !FlagArray[4];
			break;
		case 'sci':								// signals scientific display format
			FlagArray[5] = !FlagArray[5];
			break;
		case 'eng':								// signals engineering display format
			FlagArray[6] = !FlagArray[6];
			break;
		case 'fix':								// signals fixed display format
			FlagArray[7] = !FlagArray[7];
			break;
		case 'deg':								// signals degrees for calculations
			FlagArray[8] = !FlagArray[8];
			break;
		case 'rad':								// signals radians for calculations
			FlagArray[9] = !FlagArray[9];
			break;
		case 'grad':							// signals gradient for calculations
			FlagArray[10] = !FlagArray[10];
			break;
		case 'f':								// waiting for key press
			FlagArray[11] = !FlagArray[11];
			break;
		case 'g':								// waiting for key press
			FlagArray[12] = !FlagArray[12];
			break;
		case 'sto':								// waiting for register number
			FlagArray[13] = !FlagArray[13];
			break;
		case 'rcl':								// waiting for register number
			FlagArray[14] = !FlagArray[15];
			break;
		case 'goto':							// waiting for pgrm line number
			FlagArray[15] = !FlagArray[15];
			break;
		case 'rs':								//  running a program
			FlagArray[16] = !FlagArray[16];
			break;
		case 'dec':								//  waiting for number of decs to display
			FlagArray[17] = !FlagArray[17];
			break;
		case 'eex':								//  waiting for number of exponent & sign
			FlagArray[18] = !FlagArray[18];
			break;
		case 'sigPlus':							//  don't raise stack for RCL if true
			FlagArray[19] = !FlagArray[19];
			break;
		case 'nPushX':							// need to push X when new num is entered
			FlagArray[20] = !FlagArray[20];
			break;
	}
}

function getFlag(flag){
	switch (flag)
	{
		case 'power':
			return FlagArray[0];
			break;
		case 'pgrm':
			return FlagArray[1];
			break;
		case 'error':
			return FlagArray[2];
			break;
		case 'newNum':
			return FlagArray[3];
			break;
		case 'lastX':
			return FlagArray[4];
			break;
		case 'sci':
			return FlagArray[5];
			break;
		case 'eng':
			return FlagArray[6];
			break;
		case 'fix':
			return FlagArray[7];
			break;
		case 'deg':
			return FlagArray[8];
			break;
		case 'rad':
			return FlagArray[9];
			break;
		case 'grad':
			return FlagArray[10];
			break;
		case 'f':
			return FlagArray[11];
			break;
		case 'g':
			return FlagArray[12];
			break;
		case 'sto':
			return FlagArray[13];
			break;
		case 'rcl':
			return FlagArray[14];
			break;
		case 'goto':
			return FlagArray[15];
			break;
		case 'rs':
			return FlagArray[16];
			break;
		case 'dec':
			return FlagArray[17];
			break;
		case 'eex':
			return FlagArray[18];
			break;
		case 'sigPlus':
			return FlagArray[19];
			break;
		case 'nPushX':
			return FlagArray[20];
			break;
	}
}

function showRegs(){
	
	const registers = `<table>
		<tbody>
			<tr>
				<th>X</th>
				<td>${X}</td>
			</tr>
			<tr>
				<th>Y</th>
				<td>${Y}</td>
			</tr>
			<tr>
				<th>Z</th>
				<td>${Z}</td>
			</tr>
			<tr>
				<th>T</th>
				<td>${T}</td>
			</tr>
			<tr>
				<th>LastX</th>
				<td>${LastX}</td>
			</tr>
		</tbody>`;
		return registers;
//	if (ShowHideState){
//		document.getElementById("demo").innerHTML = '';
//		ShowHideState= !ShowHideState;
//	}
//	else {
//		document.getElementById("demo").innerHTML = registers;
//		ShowHideState= !ShowHideState;
//	}
}

function showFlags(){
	const div = document.getElementsByTagName("div")[1];

	const flags = `<table>
		<tbody>
			<tr>
				<th>Power</th>
				<th>Prgm</th>
				<th>Error</th>
				<th>New Num</th>
				<th>LastX</th>
				<th>Sci</th>
				<th>Eng</th>
				<th>Fix</th>
				<th>Deg</th>
				<th>Rad</th>
				<th>Grad</th>
				<th>f</th>
				<th>g</th>
				<th>Sto</th>
				<th>RCL</th>
				<th>Goto</th>
				<th>R/S</th>
				<th>Dec</th>
				<th>EEX</th>
				<th>E+</th>
			</tr>
			<tr>
				<td>${FlagArray[0]}</td>
				<td>${FlagArray[1]}</td>
				<td>${FlagArray[2]}</td>
				<td>${FlagArray[3]}</td>
				<td>${FlagArray[4]}</td>
				<td>${FlagArray[5]}</td>
				<td>${FlagArray[6]}</td>
				<td>${FlagArray[7]}</td>
				<td>${FlagArray[8]}</td>
				<td>${FlagArray[9]}</td>
				<td>${FlagArray[10]}</td>
				<td>${FlagArray[11]}</td>
				<td>${FlagArray[12]}</td>
				<td>${FlagArray[13]}</td>
				<td>${FlagArray[14]}</td>
				<td>${FlagArray[15]}</td>
				<td>${FlagArray[16]}</td>
				<td>${FlagArray[17]}</td>
				<td>${FlagArray[18]}</td>
				<td>${FlagArray[18]}</td>
			</tr>
		</tbody>
	</table>
	<br/>
	<table>
		<tbody>
			<tr>
				<th>Stack Pos</th>
				<th>Value</th>
			</tr>
			<tr>
				<td>X</td>
				<td>${X}</td>
			</tr>
			<tr>
				<td>Y</td>
				<td>${Y}</td>
			</tr>
			<tr>
				<td>Z</td>
				<td>${Z}</td>
			</tr>
			<tr>
				<td>T</td>
				<td>${T}</td>
			</tr>
			<tr>
				<td>LastX</td>
				<td>${LastX}</td>
			</tr>
		</tbody>
	</table>
	<br/>
	<table>
		<body>
			<tr>
				<th>Register</th>
				<th>Value</th>
			</tr>
			<tr>
				<td>R0</td>
				<td>${R07[0]}</td>
			</tr>
			<tr>
				<td>R1</td>
				<td>${R07[1]}</td>
			</tr>
			<tr>
				<td>R2</td>
				<td>${R07[2]}</td>
			</tr>
			<tr>
				<td>R3</td>
				<td>${R07[3]}</td>
			</tr>
			<tr>
				<td>R4</td>
				<td>${R07[4]}</td>
			</tr>
			<tr>
				<td>R5</td>
				<td>${R07[5]}</td>
			</tr>
			<tr>
				<td>R6</td>
				<td>${R07[6]}</td>
			</tr>
			<tr>
				<td>R7</td>
				<td>${R07[7]}</td>
			</tr>
		</body>
	</table>`
	
	if (ShowHideState){
		div.innerHTML = '';
		ShowHideState= !ShowHideState;
	}
	else {
		div.innerHTML = flags;
		ShowHideState= !ShowHideState;
	}
}

function findBtnFmClk(x,y)
{
	const KEY_HT = 31;
	const KEY_WN = 35;
	const KEY_WM = 40;
	const KEY_WW = 83;
	
	const PGRM_RUNX = 200;
	const ON_OFFX = 88;
	const PGRM_RUNY = 118;
	const ON_OFFY = 118;
	const PGRM_RUNW = 36;
	const ON_OFFW = 36;
	const PGRM_RUNH = 14;
	const ON_OFFH = 14;

	const FXN_KEY_RECT_BEGX = 49;
	const FXN_KEY_RECT_ENDX = 266;	// 231 + 35
	const FXN_KEY_RECT_BEGY = 162;
	const FXN_KEY_RECT_ENDY = 300;	// 259 + 31

	const KEY_PAD_RECT_BegX = 49;
	const KEY_PAD_RECT_ENDX = 275;	// 225 + 40
	const KEY_PAD_RECT_BegY = 323;
	const KEY_PAD_RECT_ENDY = 515;	// 474 + 31
	
	let rowCol = '00';

	if (PGRM_RUNY<=y && y<=PGRM_RUNY + PGRM_RUNH)	// power or pgrm
	{
		if (ON_OFFX<=x && x<=ON_OFFX + ON_OFFW) {rowCol = '01';}
		if (PGRM_RUNX<=x && x<=PGRM_RUNX + PGRM_RUNW) {rowCol = '02';}
	}
	else if (FXN_KEY_RECT_BEGY<=y && y<=FXN_KEY_RECT_ENDY)	// function key rectangle
	{
		if (y<=FXN_KEY_RECT_BEGY + KEY_HT)	// first row of fxn keys
		{
			if (FXN_KEY_RECT_BEGX<=x && x<=FXN_KEY_RECT_BEGX + KEY_WN) {rowCol = '11';}
			else if (97<=x && x<=97+KEY_WN) {rowCol = '12';}
			else if (145<=x && x<=145+KEY_WN) {rowCol = '13';}
			else if (192<=x && x<=192+KEY_WN) {rowCol = '14';}
			else if (241<=x && x<=241+KEY_WN) {rowCol = '15';}
		}
		else if (216<=y && y<=216+KEY_HT)	// second row of function keys
		{
			if (FXN_KEY_RECT_BEGX<=x && x<=FXN_KEY_RECT_BEGX + KEY_WN) {rowCol = '21';}
			else if (97<=x && x<=97+KEY_WN) {rowCol = '22';}
			else if (145<=x && x<=145+KEY_WN) {rowCol = '23';}
			else if (192<=x && x<=192+KEY_WN) {rowCol = '24';}
			else if (241<=x && x<=241+KEY_WN) {rowCol = '25';}
		}
		else if (269<=y && y<=269+KEY_HT)	// third row of function keys
		{
			if (FXN_KEY_RECT_BEGX<=x && x<=FXN_KEY_RECT_BEGX + KEY_WW) {rowCol = '31';}
			else if (145<=x && x<=145+KEY_WN) {rowCol = '32';}
			else if (192<=x && x<=192+KEY_WN) {rowCol = '33';}
			else if (241<=x && x<=241+KEY_WN) {rowCol = '34';}
		}
	}
	else if (KEY_PAD_RECT_BegY<=y && y<=KEY_PAD_RECT_ENDY)	// keypad rectangle
	{
		if (y<=KEY_PAD_RECT_BegY + KEY_HT)	// first row
		{
			if (KEY_PAD_RECT_BegX<=x && x<=KEY_PAD_RECT_BegX + KEY_WN) {rowCol = '41';}
			else if (108<=x && x<=108 + KEY_WM) {rowCol = '42';}
			else if (172<=x && x<=172 + KEY_WM) {rowCol = '43';}
			else if (235<=x && x<=235 + KEY_WM) {rowCol = '44';}
		}
		else if (376<=y && y<=376 + KEY_HT)	// second row
		{
			if (KEY_PAD_RECT_BegX<=x && x<=KEY_PAD_RECT_BegX + KEY_WN) {rowCol = '51';}
			else if (108<=x && x<=108 + KEY_WM) {rowCol = '52';}
			else if (172<=x && x<=172 + KEY_WM) {rowCol = '53';}
			else if (235<=x && x<=235 + KEY_WM) {rowCol = '54';}
		}
		else if (430<=y && y<=430 + KEY_HT)	// third row
		{
			if (KEY_PAD_RECT_BegX<=x && x<=KEY_PAD_RECT_BegX + KEY_WN) {rowCol = '61';}
			else if (108<=x && x<=108 + KEY_WM) {rowCol = '62';}
			else if (172<=x && x<=172 + KEY_WM) {rowCol = '63';}
			else if (235<=x && x<=235 + KEY_WM) {rowCol = '64';}
		}
		else if (484<=y && y<=483 + KEY_HT)	// fourth row
		{
			if (KEY_PAD_RECT_BegX<=x && x<=KEY_PAD_RECT_BegX + KEY_WN) {rowCol = '71';}
			else if (108<=x && x<=108 + KEY_WM) {rowCol = '72';}
			else if (172<=x && x<=172 + KEY_WM) {rowCol = '73';}
			else if (235<=x && x<=235 + KEY_WM) {rowCol = '74';}
		}
	}
	return rowCol;
}

function errorCond(warning) {
	alert(warning);
}

function twoNumStkShft(){				// takes care of stack after two number math function
	[Y,Z] = [Z,T];
}

function pushX(num){
	[X,Y,Z,T] = [num,X,Y,Z];
}

// Plan to rewrite the following to display numbers formatted like the HP-25.
// Initially shows two decimals, so 0 is shown as 0.00.
// Have a global for the number of significant figures: NumDecimals.
// It is initialized to two displayed decimals.
// Need to implement three different number formats, fixed, sci, and eng.
// Ideally this function will also display any error messages appropriately.
// Longer term goal will be to display data via old fashioned parts of an "8".
// In the short term will fake this with an appropriate font.
// Downloaded Digital-7 Italic font and will see if that fits the bill (in red!)
// A flag is needed during digital accumulation as the display is what has been 
// entered, not X. Or a true/false parameter indicating data accumulation.

// Maximum 10 digit number in fixed mode with room for the sign even when positive.
// Decimal point does not take up a "space", but is situated close to the previous num.
// Fixed can display from 0 to 9 decimals. Ten is maximum number of digits displayed in 
// fixed format, 8 in sci with 7 after the decimal. One can key in SCI 8 or 9, but 
// the rounding is lost in the display of 7 digits after the decimal.
// Eng is sci, but only uses exponents that are multiples of 3. Number keyed in 
// determines how many digits are displayed after the first three, eg 0->3 & 1->4.
// Also need to ensure that if the number is too small or large to switch from fixed 
// to SCI 7 in order to show the desired number os significant digits.
// After an auto switch to sci 7, entering a new number or CLX causes auto shift back 
// to FIX n that was set before the auto shift to SCI 7.
// What number is too small varies based on the decimals shown in FIX. If it will look 
// like zero an automatic shift to SCI 7 happens.
// Numbers > 10^10 will cause an automatic shift to SCI 7.

function display(numStr){				// display the passed string of digits
	document.getElementById('display').value = numStr;
}

function round(num,dec){		// returns num rounded to the number of decimals
								// specified by dec
	const timesTen = Math.round(num * 10 ** dec);
	return timesTen / 10 ** dec;
}

function getExp(fraction){				// finds the number of 10 factors required to increase
	let counter = 0;					// a number to greater then 1
	let posFrac = Math.abs(fraction);
	while (posFrac < 1){
		posFrac = 10 * posFrac;
		counter++;
	}
	return counter;
}

function pad(numStr){								// takes a positive argument
	let arrOfStrs = ["",""];
	let expSign = "";
	if (numStr.includes('+')){
		arrOfStrs = numStr.split('e+');					// now have array [1.123,2]
		expSign = " ";
	}
	else{													// numStr must be negative
		arrOfStrs = numStr.split('e-');
		expSign = "-";
	}
	const lenMan = arrOfStrs[0].length;				// includes int and .
	const lenExp = arrOfStrs[1].length;
	if (lenExp == 1){
		arrOfStrs[1] = '0' + arrOfStrs[1];
	}															// add 0 if needed
	if (lenMan < 8){
		arrOfStrs[0] = `${arrOfStrs[0]}${" ".repeat(9 - lenMan)}`;	// add spaces
	}
	return `${arrOfStrs[0]}${expSign}${arrOfStrs[1]}`;	// returns a string
}

function dispFix(num){
	const dec = NumDecimals;
	let numStr = "";
	if (num > 10 ** 10){					// upper limit for numbers in FIX notation
		numStr = dispSci(num,7);			// auto switch to SCI 7
	}
	else if (num != 0 && Math.abs(num) < 1 && getExp(num) > dec){	// lower limit for numbers in FIX notation
		numStr = dispSci(num,7);			// auto switch to SCI 7
	}
	else {
		numStr = new Number(num).toFixed(dec);	// get a string
		if (num >= 0){							// if positive add space up front
			numStr = " " + numStr;
		}
	}
	return numStr;
}

function dispSci(num){							// takes a number as argument
	let strNum = "";
	let tempNum = num;
	if (num < 0){tempNum = Math.abs(num)}				
	strNum = tempNum.toExponential(NumDecimals)		// now have 1.00e+1

	strNum = pad(strNum);						// adds spaces between mantissa and exp
	if (num > 0){
		strNum = " " + strNum;					// add a space for sign
	}
	else {
		strNum = "-" + strNum;
	}
	return strNum;
}

function shiftTen (strNum) {		// shifts dec to right in str representation of num
	const strNumArr = strNum.split('.');
	return `${strNumArr[0]}${strNumArr[1].slice(0,1)}.$strNumArr[1]`
}

function dispEng(num) {				// exponents in factors of 3: 3, 6, 9, -3, -6, ...
	let strNum = "";
	let tempNum = num;
	if (num < 0){empNum = Math.abs(num)}
	NumDecimals (NumDecimals < 2) ? NumDecimals = 2: NumDecimals;
			
	strNum = tempNum.toExponential(NumDecimals)		// now have 1.00e+1
	let exponent = strNum.substring(strNum.indexOf('e'));
	let exp = parseInt(exponent);							// NEED TO DEAL WITH SIGN
	let mantissa = strNum.substring(0,strNum.indexOf('e'));
	if (!(exp % 3 == 0)) {						// need to shift decimal
		if ((exp + 1) % 3 == 0) {				// need to shift by factor of 10
			exp = exp - 1;
			mantissa = shiftTen(mantissa);
		}
		else if ((exp + 2) % 3 == 0) {			// need to shift by factor of 100
			exp = exp - 2;
			mantissa = shiftTen(mantissa);
			mantissa = shiftTen(mantissa);
		}
	}											// now put it back together
	exponent = exp.toString();
	strNum = `${mantissa}'e+'${exponent}`;

	strNum = pad(strNum);						// adds spaces between mantissa and exp
	if (num > 0){
		strNum = " " + strNum;					// add a space for sign
	}
	else {
		strNum = "-" + strNum;
	}
	return strNum;
}


function recall(digit){						// put register into X and raise stack
	if (flagIsOn(SigPlusM)){				// any other flags to check?
		X = R07[digit];
		updateDisp(false);					// don't push onto stack just replace X
	}
	else {
		pushX(R07[digit]);
		updateDisp(false);
	}
	flagOn(RecallM);
}

function store(digit){
	if (storeFxn == ''){				// no math fxn selected prior to register number
		R07[digit] = X;					// store X in register specified
	}
	else {								// a math fxn was selected prior to reg number
		switch (storeFxn){
			case 'add':					// need to check for overflow > 9.999999999E99
				R07[digit] = R07[digit] + X;
				break;
			case 'subtract':
				R07[digit] = R07[digit] - X;
				break;
			case 'multiply':			// need to check for overflow > 9.999999999E99
				R07[digit] = R07[digit] * X;
				break;
			case 'divide':
				R07[digit] = R07[digit] / X;
				break;
		}
		flagOn(StoreM);
		storeFxn = '';
	}
}

function collectData(digit)
{										// need to trap register number or set sigfigs
	if (flagIsOn(StoreM)) {				// need to store a number
		store(digit,"");
		flagOff(StoreM);
	}
	else if (flagIsOn(RecallM)) {			// need to recall a number
		recall(digit);
		flagOff(RecallM);
	}
	else if (flagIsOn(DecM)) {			// need to set sigfigs
		NumDecimals = parseInt(digit);
		flagOff(DecM);					// reset flag to false
		updateDisp(false);
	}
	else if (flagIsOn(EexM)) {			// capture digits in exponent
		DataAccum.setExp(digit);
	}
	else {
		DataAccum.setMantissa(digit);
		updateDisp(true);
	}
}

function power(){
	if (flagIsOn(PowerM)){									// power was on
		flagOff(PowerM);									// set flag to off
		document.getElementById("display").value = '';		// blank the display
		initStack();
		Flags = 0;
		initReg();
		DataAccum.clearData();	// used it so now clear it
		
	}
	else{													// power was off
		Flags = 0;									// initialize globals
		initNumDecimals();
		initStack();
		initReg();
		initPrgmMem();
		flagOn(PowerM);									// set flag to on
		flagOn(FixM);										// default display
		flagOn(DegM);										// default trig
		flagOn(NPushXM);									// ready for num entry
		X = 0;
		updateDisp(false);
	}
}

function prefix(fg){
	if (fg === 'f'){
		flagOn(FM);
		const code = '14';
	}
	else{								// must be g
		flagOn(GM);
		const code = '15';
	}
	if (getFlag('1')){					// record as prgm step (need repair here!!)
		PrgmMem[PrgmPos] = code			// but do not advance PrgmPos
	}
}

function calcMean() {
	if (R07[3] <= 0){
		errorCond("Must have two or more samples");
	}
	else{							// calculate the mean using R3 & R7
		X = R07[7] / R07[3];		// sum of entries over number of entries
		flagOn(NPushXM);
		updateDisp(false);
	}
}

function percentage() {				// not twoNumFunc() as Y is not changed
	// LastX = X;					// no lastX for percent
	X = Y * X / 100;				// X replaced; Y stays unchanged
	DataAccum.clearData();
	flagOn(NPushXM);
	updateDisp(false);
}

function swapXY(){					// swap X and Y registers
	[X,Y] = [Y,X];					// destructuring to the rescue
	flagOn(NPushXM);
	updateDisp(false);
}

function stdDev() {
	if (R07[3] <= 1) {
		errorCond("Must have two or more samples");
	}
	else {
		X = Math.sqrt((R07[7] - R07[6]*R07[6]/R07[3])/(R07[3] - 1));
		flagOn(NPushXM);
		updateDisp(false);				// sqrt((R7 - R6*R6/R3)/(R3 - 1))
	}
}

function oneNumFunc(func) {		// func is str representing the function called
// before calling func need to check newNum and put accumulating number into X
	DataAccum.clearData();	// used it so now clear it
	flagOn('nPushX');		// turn it on for next number
	LastX = X;
	switch (func)
	{
		case '1OverX':
			 X = oneOverX(X);
			break;
		case 'frac':
			X = frac(X);
			break;
		case 'int':
			X = intPart(X);
			break;
		case 'sqrt':
			X = sqrt(X);
			break;
		case 'square':
			X = square(X);
			break;
		case 'absVal':
			X = absVal(X);
			break;
		case 'natLog':
			X = natLog(X);
			break;
		case 'eToX':
			X = eToX(X);
			break;
		case 'log':
			X = log(X);
			break;
		case 'tenToX':
			X = tenToX(X);
			break;
		case 'hms':
			X = hms(X);
			break;
		case 'decFmHMS':
			X = decFmHMS(X);
			break;
		case 'sine':
			X = trig('sin', X, false);
			break;
		case 'cosine':
			X = trig('cos', X, false);
			break;
		case 'tan':
			X = trig('tan', X, false);
			break;
		case 'arcsine':
			X = trig('sin', X, true);
			break;
		case 'arccos':
			X = trig('cos', X, true);
			break;
		case 'arctan':
			X = trig('tan', X, true);
			break;
	}
	
	function oneOverX(num) {		// NEED TO REDO ERROR WITH FLAG AND COMMENT STORAGE
		if (num === 0) {
			errorCond("Can't divide by zero");
		}
		else {
			return 1 / num;						// 1/X
		}
	}
	
	function natLog(num){
		if (num <= 0){					// error
			errorCond("Can't take ln of negative number or 0");
		}
		else {
			return Math.log(num);
		}
	}

	function eToX(num){
		return Math.exp(num);
	}

	function log(num){
		if (num <= 0){					// error
			errorCond("Can't take log of negative number or 0");
		}
		else {
			return Math.log(num)/Math.log(10);
		}
	}

	function tenToX(num){
		return 10 ** num;
	}

	function frac(num) {				// returns decimal part of real number
		return num - Math.floor(num);
	}

	function intPart(num){			// returns integer part of real number
		return Math.floor(num);
	}
	
	function sqrt(num) {
		if (num < 0){
			errorCond("Can't take square root of negative number");
		}
		else{
			return Math.sqrt(num);
		}
	}
	
	function square(num) {
		const sqrd = num * num;
		if (sqrd > 9.9999999e99) {
			errorCond("Result is too large for the HP-25")
		}
		else {
			return sqrd;
		}
	}
	
	function absVal(num) {
		return Math.abs(num);
	}

	function hms(num){
		const hours = Math.floor(num);
		let temp = 60 * frac(num);
		let minutes = Math.floor(temp);
		let seconds = frac(temp) * 60;
		return hours + minutes/100 + seconds/10000;
	}

	function decFmHMS(num){
		const hours = Math.floor(num);
		let temp = 100 * frac(num);
		const mins = Math.floor(temp);
		let secs = 100 * frac(temp);
		return hours + (secs/60 + mins)/60;
	}

	function drgConv(num,notInv){			// converts radians and grads to degrees
		if (notInv){						// convert to degrees before calc if needed
			if (flagIsOn(RadM)){
				return num*2*Math.PI/360;
			}
			else if (flagIsOn(GradM)){
				return num*400/360;
			}
			else{							// assumes degrees as default
				return num;
			}
		}
		else{								// converting to rads or grads after calc
			if (flagIsOn(RadM)){
				return num*360/(2*Math.pi);
			}
			else if (flagOn(GradM)){
				return num*360/400;
			}
			else{							// assumes degrees as default
				return num;
			}
		}
	}

	function trig(func,num,inv){			// returns answer dependent on deg/rad/grad
		if (inv){							// an inverse trig function
			switch (func){
				case 'arcsin':
					if (Math.abs(num) < 1){
						return degConv(Math.asin(num),false);
					}
					else{
						errorCond("Number outside the range -1 to 1");
					}
					break;
				case 'arccos':
					if (Math.abs(num) < 1){
						return  degConv(Math.acos(num),false);
					}
					else{
						errorCond("Number outside the range -1 to 1");
					}
					break;
				case 'arctan':
					return  degConv(Math.atan(num),false);
					break;
			}
		
		}
		else{
			const deg = drgConv(num,true);
			switch (func)
			{
				case 'sin':
					return Math.sin(deg);
					break;
				case 'cos':
					return Math.cos(deg);
					break;
				case 'tan':
					return Math.tan(deg);
					break;
			}
		}
	}
	updateDisp(false);
}


function rollDown(){
	[X,Y,Z,T] = [Y,Z,T,X];			// destructuring to the rescue
	flagOn(NPushXM);				// ready for new number entry 
	updateDisp(false);
}

function sigmaPlus() {					// number entry is followed by enter prior to sigP
	if (flagIsOn(FM)) {					// sigma -
		flagOff(FM);
		R07[3]--;						
		R07[4] = R07[4] - Y;
		R07[5] = R07[5] - X * Y;
		R07[6] = R07[6] - X * X;
		R07[7] = R07[7] - X;
		// LastX = X;					// no LastX saves in sig plus or minus
		X = R07[3];
		flagOff(SigPlusM);				// not needed here, but return to false
		updateDisp(false);
	}
	else if (flagIsOn('g')){				// no g function on this key
		flagOff(GM);
	}
	else {								// use contents of X & Y registers
		R07[3]++;						// count of entries
		R07[4] = R07[4] + Y;			// sum of y values
		R07[5] = R07[5] + X * Y;		// sum of x*y values
		R07[6] = R07[6] + X * X;		// sum of squares of x values
		R07[7] = R07[7] + X;			// sum of x values
		X = R07[3];
		flagOff(SigPlusM);				// not needed here, but return to false
		updateDisp(false);
	}
}

function numKey(keyPressed){	// In an attempt to simplify the code for number key 
	if (flagIsOn(FM)){			// presses the logic is moved to this numKey function.
		flagOff(FM);			// The meat of execution is passed to numKeyF() or 
		funcKeyF(keyPressed);	// numKeyG().
	}
	else if (flagIsOn(GM)){
		flagOff(GM);
		funcKeyG(keyPressed);
	}
	else{
		if (flagIsOn(NPushXM)) {
			pushX(X);
			flagOff(NPushXM);
		}
		collectData(keyPressed);
	}
}

function polToRect(){			// not using twoNunFunc() as twoNumStkShft not needed
	const coordArr = polarToRect(X,Y);	// array with two coordinates is returned
	X = coordArr[0];
	Y = coordArr[1];
	LastX = X;
	flagOn(NPushXM);
	DataAccum.clearData();	// used it so now clear it
	updateDisp(false);
}

function rectToPol(){
	const coordArr = rectToPolar(X,Y);
	X = coordArr[0];
	Y = coordArr[1];
	LastX = X;
	flagOn(NPushXM);
	DataAccum.clearData();	// used it so now clear it
	updateDisp(false);
}

function lastX(){		// note that LastX is only implemented once a number button 
	pushX(LastX);		// has been pushed, so the triggers for this function need 
	DataAccum.clearData();	// used it so now clear it
	updateDisp(false);	// need to be rewritten at some point
}

function pi() {
	DataAccum.clearData();	// used it so now clear it
	// LastX = X;	for some reason pi does not save X in LastX
	pushX(Math.PI);
	flagOn(NPushXM);
	updateDisp(false);
}

function funcKeyF(keyPressed){
	switch (keyPressed)
	{
		case 'minus':			// x < y
			break;
		case 'plus':			// x >= y
			break;
		case 'times':			// x != y
			break;
		case 'divide':			// x = y
			break;
	}
	flagOff(FM);				// turn f flag off
}

function funcKeyG(keyPressed){
	switch (keyPressed)
	{
		case 'minus':			// x < 0
			break;
		case 'plus':			// x >= 0
			break;
		case 'times':			// x != 0
			break;
		case 'divide':			// x = 0
			break;
	}
	flagOff(GM);				// turn g flag off
}

function twoNumFunc(keyPressed){
// 	if (getFlag('f')){
// 		setFlag('f');
// 		funcKeyF(keyPressed);
// 	}
// 	else if (getFlag('g')){
// 		setFlag('g');
// 		funcKeyG(keyPressed);
// 	}
//	else{
		DataAccum.clearData();			// used it so now clear it
		LastX = X;
		switch (keyPressed)
		{
			case 'minus':
				minus();
				break;
			case 'plus':
				plus();
				break;
			case 'times':
				times();
				break;
			case 'divide':
				divide();
				break;
			case 'yToX':
				yToX();
				break;
		}
		twoNumStkShft();
		if (!flagIsOn(NPushXM)) { flagOn(NPushXM); }
		updateDisp(false);
//	}
	function minus(){
		X = Y - X;
	}

	function plus(){
		X = Y + X;			// need overflow check
	}

	function times(){
		X = Y * X;			// need overflow check
	}

	function divide(){
		if (X != 0){
			X = Y / X;
		}
		else{
			errorCond("Can't divide by zero");
		}
	}

	function yToX(){
		if (Y <= 0){
			errorCond("Can't raise negative number or 0 to a power");
		}
		else {
			X = Y ** X;
		}
	}

}

function enter(){
	if (flagIsOn(FM)){					// Clear Prefix
		flagOff(FM);					// also clear STO, RCL, & GOTO
		if (flagIsOn(GM)){flagOff(GM)};
		if (flagIsOn(StoreM)){flagOff(StoreM)};
		if (flagIsOn(RecallM)){flagOff(RecallM)};
		if (flagIsOn(GoToM)){flagOff(GoToM)};
	}
	else if (flagIsOn(GM)){				// unused
		
	}
	else{
		if (flagIsOn(EexM)) {
			flagOff(EexM);
		}
		pushX(X);						// don't want to set flag nPushX as we just pushed
		DataAccum.clearData();			// used it so now clear it
		if (flagIsOn(NPushXM)) { flagOff(NPushXM); }
		updateDisp(false);
	}
}

function clearX(){
	X = 0.0;						// don't want to set flag nPushX as we just pushed
	DataAccum.clearData();
	updateDisp(false);
}

function setFormat(format){			// set all flags to false
	if (flagIsOn(FixM)){
		flagOff(FixM);
	}
	if (flagIsOn(SciM)){
		flagOff(SciM);
	}
	if (flagIsOn(EngM)){
		flagOff(EngM);
	}
	flagOn(format);			// then set desired flag to true
	flagOff(DecM);
	flagOff(FM);		
}


function clearStk() {
	initStack();
	flagOn(NPuxhXM);
	DataAccum.clearData();
}

function clearReg() {
	initReg();
}

function clearPgrm() {
	initPgrmMem();
}

function clearPrefix() {
	if (flagIsOn(FM)) {
		flagOff(FM);
	}
	if (flagIsOn(GM)) {
		flagOff(GM);
	}
}

function chSign()
{
	if (flagIsOn(EexM)) {
		const sign = (DataAccum.getExpSign() == " ") ? "-": " ";
		flagOn(NPushXM);
		DataAccum.setExpSign(sign);					// need to change exponent sign
		updateDisp(true);
	}
	else {
		if (X!== 0) {
			X = -X;
			updateDisp(false);
		}
		else {
			const sign = (DataAccum.getSign() == " ") ? "-": " ";
			flagOn(NPushXM);
			DataAccum.setSign(sign);					// need to change mantissa sign
			updateDisp(true);
		}
	}
}

function btnClicked(btn)
{
	if (btn == '01'){
		power();
	}
	else{
		if (flagIsOn(PowerM)){			// power is on so buttons work
			switch (btn)
			{
				case "02":	// prgm
					break;
				case "11":	// SST, Fix
					if (flagIsOn(FM)){
						setFormat(FixM);
						flagOn(NPushXM);
					}
					break;
				case "12":	// BST, Sci
					if (flagIsOn(FM)){
						setFormat(SciM);
						flagOn(NPushXM);
					}
					break;
				case "13":	// GTO, Eng
					if (flagIsOn(FM)){
						setFormat(EngM);
						flagOn(NPushXM);
					}
					break;
				case "14":	// f
					prefix('f');
					break;
				case "15":	// g
					prefix('g');
					break;
				case "21":	// x<>y, Mean, %
					if (flagIsOn(FM)) {
						calcMean();
						flagOff(FM);
					}
					else if (flagIsOn(flagIsOn)) {
						percentage();
						flagOff(GM);
					}
					else {
						swapXY();
					}
					break;
				case "22":	// R down, Std dev, 1/x
					if (flagIsOn(FM)) {
						stdDev();
						flagOff(FM);
					}
					else if (flagIsOn(GM)) {
						oneNumFunc('1OverX');
						flagOff(GM);
					}
					else {
						rollDown();
					}
					break;
				case "23":	// STO
					flagOn(StoreM);		// need to handle register math
										// number entered STO or RCL is not shown
					break;
				case "24":	// RCL
					flagOn(RecallM);		// causes stack to lift except after Enter, CLX, Sigma+
					break;
				case "25":				// Sigma +	// does Sigma - as well
					flagOn(SigPlusM);	// not sure when to turn this flag off?
					sigmaPlus();		// will need to redo this for programming
					break;
				case "31":	// Enter, Clear Prefix
					if (flagIsOn(FM)) {
						clearPrefix();
						flagOn(FM);
					}
					else {
						enter();
					}
					break;
				case "32":	// CHS, Clear Pgrm, Deg
					if (flagIsOn(FM)) {
						clearPgrm();
						flagOff(FM);
					}
					else if (flagIsOn(GM)) {
						flagOff(GM);
					}
					else {
						chSign();
					}
					break;
				case "33":	// EEX, Clear Reg, EEX
					if (flagIsOn(FM)) {
						clearReg();
						flagOff(FM);
					}
					else if (flagIsOn(GM)) {
						flagOff(GM);
					}
					else {
						flagOn(EexM);
					}
					break;
				case "34":	// CLX, Clear Stack, Grad
					if (flagIsOn(FM)) {
						clearStk();
						flagOff(FM);
					}
					else if (flagIsOn(GM)) {
						flagOff(GM);
					}
					else {
						clearX();
					}
					break;
				case "41":	// -, x<y, x<0
					if (flagIsOn(StoreM)){		// STO pushed prior to minus
						storeFxn = 'subtract';
					}
					else{
						if (flagIsOn(FM)) {
							funcKeyF('minus');
						}
						else if (flagIsOn(GM)) {
							funcKeyG('minus');
						}
						else {
							twoNumFunc('minus');
						}
					}
					break;
				case "42":	// 7, ln, e^x
					if (flagIsOn(FM)) {
						oneNumFunc('natLog');
						flagOff(FM);
					}
					else if (flagIsOn(GM)) {
						oneNumFunc('eToX');
						flagOff(GM);
					}
					else {
						numKey('7');
					}
					break;
				case "43":	// 8, log, 10^x
					if (flagIsOn(FM)) {
						oneNumFunc('log');
						flagOff(FM);
					}
					else if (flagIsOn(GM)) {
						oneNumFunc('tenToX');
						flagOff(GM);
					}
					else {
						numKey('8');
					}
					break;
				case "44":	// 9, ->R, ->P
					if (flagIsOn(FM)) {
						polToRect();
						flagOff(FM);
					}
					else if (flagIsOn(GM)) {
						rectToPol();
						flagOff(GM);
					}
					else {
						numKey('9');
					}
					break;
				case "51":	// +, x>=y, x>=0
					if (flagIsOn(StoreM)){		// STO pushed prior to plus
						storeFxn = 'add';
					}
					else{
						if (flagIsOn(FM)) {
							funcKeyF('plus');
						}
						else if (flagIsOn(GM)) {
							funcKeyG('plus');
						}
						else {
							twoNumFunc('plus');
						}
					}
					break;
				case "52":	// 4, sin, sin^(-1)
					if (flagIsOn(FM)) {
						oneNumFunc('sin');
						flagOff(FM);
					}
					else if (flagIsOn(GM)) {
						oneNumFunc('arcsin');
						flagOff(GM);
					}
					else {
						numKey('4');
					}
					break;
				case "53":	// 5, cos, cos^(-1)
					if (flagIsOn(FM)) {
						oneNumFunc('cos');
						flagOff(FM);
					}
					else if (flagIsOn(GM)) {
						oneNumFunc('arccos');
						flagOff(GM);
					}
					else {
						numKey('5');
					}
					break;
				case "54":	// 6, tan, tan^(-1)
					if (flagIsOn(FM)) {
						oneNumFunc('tan');
						flagOff(FM);
					}
					else if (flagIsOn(GM)) {
						oneNumFunc('arctan');
						flagOff(GM);
					}
					else {
						numKey('6');
					}
					break;
				case "61":	// *, x!=y, x!=0
					if (flagIsOn(StoreM)){		// STO pushed prior to times
						storeFxn = 'multiply';
					}
					else{
						if (flagIsOn(FM)) {
							funcKeyF('times');
						}
						else if (flagIsOn(GM)) {
							funcKeyG('times');
						}
						else {
							twoNumFunc('times');
						}
					}
					break;
				case "62":	// 1, int frac
					if (flagIsOn(FM)) {
						oneNumFunc('int');
						flagOff(FM);
					}
					else if (flagIsOn(GM)) {
						oneNumFunc('frac');
						flagOff(GM);
					}
					else {
						numKey('1');
					}
					break;
				case "63":	// 2, sqrt, x^2
					if (flagIsOn(FM)) {
						oneNumFunc('sqrt');
						flagOff(FM);
					}
					else if (flagIsOn(GM)) {
						oneNumFunc('square');
						flagOff(GM);
					}
					else {
						numKey('2');
					}
					break;
				case "64":	// 3, y^x, ABS
					if (flagIsOn(FM)) {
						twoNumFunc('yToX');
						flagOff(FM);
					}
					else if (flagIsOn(GM)) {
						oneNumFunc('absVal');
						flagOff(GM);			// set flag here to keep func clean
					}
					else {
						numKey('3');
					}
					break;
				case "71":	// /, x=y, x=0
					if (flagIsOn(StoreM)){		// STO pushed prior to divide
						storeFxn = 'divide';	// global to remember what to do with num
					}
					else{
						if (flagIsOn(FM)) {
							funcKeyF('divide');
						}
						else if (flagIsOn(GM)) {
							funcKeyG('divide');
						}
						else {
							twoNumFunc('divide');
						}
					}
					break;
				case "72":	// 0, ->H.MS, ->H
					if (flagIsOn(FM))  {
						oneNumFunc('hms');					// Changes decimal hrs (degs) to H.MM.SS
						flagOff(FM);
					}
					else if (flagIsOn(GM)) {
						oneNumFunc('decFmHms');
						flagOff(GM);
					}
					else {
						numKey('0');
					}
					break;
				case "73":	// ., LastX, pi
					if (flagIsOn(FM))  {
						lastX();					// replaces X with LastX
						flagOff(FM);
					}
					else if (flagIsOn(GM)) {
						pi();					// replaces X with pi
						flagOff(GM);
					}
					else {
						numKey('.');
					}
					break;
				case "74":	// R/S, Pause, NOP
					break;
			}
			addHistoryEvent(btn);
			showHistory();
		} // end of if getflag('power')
	} // end of else
}

function showCoords(event) {
    let cX = event.clientX;
    let sX = event.screenX;
    let cY = event.clientY;
    let sY = event.screenY;
    let coords1 = "client - X: " + cX + ", Y coords: " + cY;
    let coords2 = "screen - X: " + sX + ", Y coords: " + sY;
    let button = findBtnFmClk(cX,cY);						// button is array
    btnClicked(button);
    document.getElementById("demo").innerHTML = coords1 + "<br/>" + coords2 + "<br/>" + button + "<br/>" + showRegs();
	showRegs();
}

// -->

</script>

</head>
<body>

<div onclick="showCoords(event)">

<img class=inline src="hp25face.jpg" alt="HP-25 face" width="306" height="567">

<br/><br/>

<fieldset>
	<input type="text" id="display" readOnly="True">
</fieldset>
</div>

<br/><br/>

<div>
<p id="demo"></p>
<p id="demo1"></p>
</div>

<div class="history">

</div>


<footer>
	<p><a href="Math%20Calculators.html">Math Calculators</a></p>
	<p>John H. McDonald, III</p>
	<p>May 27, 2018</p>
</footer>

</body>
</html>