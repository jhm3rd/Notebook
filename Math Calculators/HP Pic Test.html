<!DOCTYPE html>
<html lang="en">
<head>
	<title>HP-25 Calculator (Pic Test)</title>
	<meta charset="utf-8">
	<meta name="keywords" content="calculator,emulator,Hewlett,Packard, HP-25"/>
	<meta name="description" content="Emulation of an HP-25 Calculator"/>

<style>
body {
	font-family: "Gill Sans", Tahoma, Arial, Geneva, sans-serif;
}
.bg-img {
	background-image: url("hp25face.jpg");
    width: 306px;
    height: 567px;
    background-position: left;
    background-repeat: no-repeat;
    background-size: cover;
    position: relative;
}

.container {
	position: absolute;
	left: 31px;
	margin: 0px;
	max-width: 300px;
	padding: 10px;
}

input[type='text'] {
	width: 100%;
	padding: 0px;
	margin: 5px 0 22px 0;
	border: none;
	background: black;
	color: red;
	font-size: 12pt;
	font-family: "Digital 7 Mono", Lucida Console, Monaco, monospace;
	font-variant: italic;
}
</style>

<script type="text/javascript">
<!--
// Will make four major changes vs HP-25.html. The first is a more full featured tool 
// for managing the accumulating information. This consists of an object holding 
// the parts of the entry and the functions for manipulating it.

// The second is moving the timing for 
// converting this accumulating info into a number in the X stack register. This has 
// been moved to the time of using it, either upon Enter or a function.

// The third is implementing a recording feature for composing a program.

// Might as well also ensure that the stack lifts at the right times and that LastX is 
// used at the right times. See page 111 of the manual for the details.

// Will also consider a fifth major change: moving the globals into an IIFE to limit 
// the number of global items and to enhance access.

// And yet, one more to consider. Wrap the oneNum and twoNum functions in overarching  
// functions to localize them and minimize the number of global functions. Also wrap 
// the entirety in the one function called by the calculator except for the needed globals.

// --------------------------------------------------------------------------- //
// Global entry info accumulator

// Create the object (not using a reference type since only one is ever needed)

let DataAccum =
{
	sign: " ",							// initialize with a space
	mantissa: "",
	expSign: " ",						// also initialize with space
	exp: "",
	
	// The four functions to set these properties.
	
	setSign: function(pm) {				// pm is the char to replace the space
		this.sign = pm;
	},
	
	setMantissa: function(digit) {		// digit is new digit to be added to mantissa
		this.mantissa = this.mantissa + digit;
	},
	
	// the following two setters need to have range checking built in.
	// Mantissa is too big >= 1,000,000,000.
	// Mantissa is too small first non-zero digit occurs after first eight digits,
	// e.g. 0000.000025 cannot have an exponent.
	
	tooBig: function(digit) {			// returns boolean: true if too big for exponent
		const newExp = this.exp + digit;
		let flag = false;
		if (parseInt(newExp) > 99 || parseInt(newExp) < -99) {	// cheated here
			flag = true;
		}
		if (parseFloat(this.mantissa) >= 1000000000) {
			flag = true;
		}
		return flag;
	},
	
	tooLittle: function() {			// returns boolean; true if too small for exponent
		const mant = this.mantissa;
		const len = mant.length;
		if (len > 8) {				// must have at least 8 zeros before 1st sig fig
			let i = 0;
			for (i = 0; i <= len-1; i++) {	// check each char to see if it is zero
				if (mant.charAt(i) == "0" || mant.charAt(i) == ".") {}
				else { break; }
			}
			return (i >= 8) ? true : false;
		} 
	},
	
	setExpSign: function(pm) {
		if (!this.tooBig('') && !this.tooLittle()) {
			this.expSign = pm;
		}
		else {
			errorCond("Number is out of range for an exponent");
		}
	},
	setExp: function(digit) {
		if (!this.tooBig(digit) && !this.tooLittle()) {
			if (digit == "0") {
				if (this.exp == '') {
					this.exp = "00";
				}
				else {
					this.exp = this.exp + digit;
				}
			}
			else {
				if (this.exp == "00") {
					this.exp = digit;
				}
				else {
					this.exp = this.exp + digit;
				}
			}
			if (this.mantissa == "") {
				this.mantissa = "1";
			}
		}
		else {
			errorCond("Number is out of range for an exponent");
		}
	},
	
	// the four functions to get these properties
	
	getSign: function() {
		return this.sign;
	},
	getMantissa: function() {
		return this.mantissa;
	},
	getExpSign: function() {
		return this.expSign;
	},
	getExp: function() {
		return this.exp;
	},
	
	// Other useful functions
	
	convertToNum: function() {				// four property strings to a number
		let ourNum = parseFloat(this.mantissa);
		if (this.sign == "-") {				// if we have a negative sign
			ourNum = ourNum * -1;
		}
		if (this.exp != "") {				// if we have an exponent
			let exponent = parseInt(this.exp);
			if (this.expSign == "-") {		// if we have a sign for the exponent
				exponent = exponent * -1;
			}
			ourNum = ourNum * 10 ** exponent;
		}
		return ourNum;
	},
	
	negativeNum: function() {				// returns  true for a negative number
		return (this.sign == "-") ? true : false;
	},
	
	negativeExp: function() {				// returns  true for a negative exponent
		return (this.expSign == "-") ? true : false;
	},
	
	accumulatedData: function() {			// returns a displayable number
											// need to pad for entered exponents
		const padding = " ".repeat(15 - this.getMantissa().length);
		return `${this.getSign()}${this.getMantissa()}${padding}${this.getExpSign()}${this.getExp()}`;
	},
	
	clearData: function() {
		this.sign = " ";
		this.mantissa = "";
		this.expSign = " ";
		this.exp = "";
	}
}

function updateDisp(accumulating){		// accumulating is boolean

	let numStr = "";					// displayed number is not rounded during entry
	if (accumulating){					// display updates during the entry process
		display(DataAccum.accumulatedData());
		if (getFlag('nPushX')) {			// first new digit so stack lifts
			pushX(DataAccum.convertToNum());
			setFlag('nPushX');				// set to false as we have already pushed
		}
		else {
			X = DataAccum.convertToNum();	// update X with every number entered
		}
	}
	else {
		if (getFlag('eng')){				// engineering format
			numStr = dispEng(X);			// returns X formatted in ENG n
		}
		else if (getFlag('sci')){			// scientific format
			numStr = dispSci(X);			// returns X formatted in SCI n
		}
		else {								// fixed format, the default
			numStr = dispFix(X);			// returns X formatted in FIX n
		}
		display(numStr);
	}
}


// Global flags

//  19 flags at this point
//	power, pgrm, error, newNum, lastX, sci, eng, fix, deg, rad, grad, f, g, store, recall, goto, r/s, dec, eex

let FlagArray = [];

//  Error conditions:
//  1/0 (done), y^x when Y<=0 (done), sqrt(x) when x<0 (done), log x when x<=0 (done), ln x when x<=0 (done), sin^-1 x 
//  when |x|>1 (done), cos^-1 x when |x|>1 (done), STO / when x=0, x bar when n<=0 (done), and s when n<=1 (done)

// Global settings

let NumDecimals = 0;	//  The number of mantissa elements displayed in given format

// Global registers

// Storage stack

let X=0, Y=0, Z=0, T=0;

let LastX = 0;

// Storage registers

let R07 = [];

// Program registers

let PgrmMem = [];
let PgrmPos = 0;

// storage for +, -, *, or / after STO

let storeFxn = '';

// debug global

let ShowHideState = false;

// end of Global variables

// initialization functions

function initFlagArray(){
	FlagArray = [false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false];
}

function initNumDecimals(){
	NumDecimals = 2;
}

function initStack(){
	X = 0;
	Y = 0;
	Z = 0;
	T = 0;
	LastX = 0;
}

function initReg(){
	R07 = [0,0,0,0,0,0,0,0];
}

function initPrgmMem(){		// all mem cells filled with GTO 00 except 00, which has auto stop command
	PgrmMem = ['','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00','13 00'];
}

function initPgrmPos(){
	PgrmPos = 0;
}

function setFlag(flag){
	switch (flag)
	{
		case 'power':							// on/off state for calculator
			FlagArray[0] = !FlagArray[0];
			break;
		case 'pgrm':							// need to record program
			FlagArray[1] = !FlagArray[1];
			break;
		case 'error':							// need to clear error
			FlagArray[2] = !FlagArray[2];
			break;
		case 'newNum':							// starting a new number
			FlagArray[3] = !FlagArray[3];
			break;
		case 'lastX':							// need to update LastX
			FlagArray[4] = !FlagArray[4];
			break;
		case 'sci':								// signals scientific display format
			FlagArray[5] = !FlagArray[5];
			break;
		case 'eng':								// signals engineering display format
			FlagArray[6] = !FlagArray[6];
			break;
		case 'fix':								// signals fixed display format
			FlagArray[7] = !FlagArray[7];
			break;
		case 'deg':								// signals degrees for calculations
			FlagArray[8] = !FlagArray[8];
			break;
		case 'rad':								// signals radians for calculations
			FlagArray[9] = !FlagArray[9];
			break;
		case 'grad':							// signals gradient for calculations
			FlagArray[10] = !FlagArray[10];
			break;
		case 'f':								// waiting for key press
			FlagArray[11] = !FlagArray[11];
			break;
		case 'g':								// waiting for key press
			FlagArray[12] = !FlagArray[12];
			break;
		case 'sto':								// waiting for register number
			FlagArray[13] = !FlagArray[13];
			break;
		case 'rcl':								// waiting for register number
			FlagArray[14] = !FlagArray[14];
			break;
		case 'goto':							// waiting for pgrm line number
			FlagArray[15] = !FlagArray[15];
			break;
		case 'rs':								//  running a program
			FlagArray[16] = !FlagArray[16];
			break;
		case 'dec':								//  waiting for number of decs to display
			FlagArray[17] = !FlagArray[17];
			break;
		case 'eex':								//  waiting for number of exponent & sign
			FlagArray[18] = !FlagArray[18];
			break;
		case 'sigPlus':							//  don't raise stack for RCL if true
			FlagArray[19] = !FlagArray[19];
			break;
		case 'nPushX':							// need to push X when new num is entered
			FlagArray[20] = !FlagArray[20];
			break;
	}
}

function getFlag(flag){
	switch (flag)
	{
		case 'power':
			return FlagArray[0];
			break;
		case 'pgrm':
			return FlagArray[1];
			break;
		case 'error':
			return FlagArray[2];
			break;
		case 'newNum':
			return FlagArray[3];
			break;
		case 'lastX':
			return FlagArray[4];
			break;
		case 'sci':
			return FlagArray[5];
			break;
		case 'eng':
			return FlagArray[6];
			break;
		case 'fix':
			return FlagArray[7];
			break;
		case 'deg':
			return FlagArray[8];
			break;
		case 'rad':
			return FlagArray[9];
			break;
		case 'grad':
			return FlagArray[10];
			break;
		case 'f':
			return FlagArray[11];
			break;
		case 'g':
			return FlagArray[12];
			break;
		case 'sto':
			return FlagArray[13];
			break;
		case 'rcl':
			return FlagArray[14];
			break;
		case 'goto':
			return FlagArray[15];
			break;
		case 'rs':
			return FlagArray[16];
			break;
		case 'dec':
			return FlagArray[17];
			break;
		case 'eex':
			return FlagArray[18];
			break;
		case 'sigPlus':
			return FlagArray[19];
			break;
		case 'nPushX':
			return FlagArray[20];
			break;
	}
}

function showRegs(){
	
	const registers = `<table>
		<tbody>
			<tr>
				<th>T</th>
				<td>${T}</td>
			</tr>
			<tr>
				<th>Z</th>
				<td>${Z}</td>
			</tr>
			<tr>
				<th>Y</th>
				<td>${Y}</td>
			</tr>
			<tr>
				<th>X</th>
				<td>${X}</td>
			</tr>
			<tr>
				<th>LastX</th>
				<td>${LastX}</td>
			</tr>
		</tbody>
			<br/>
	</table>
	<table>
		<tbody>
			<tr>
				<th>Register</th>
				<th>Value</th>
			</tr>
			<tr>
				<td>R0</td>
				<td>${R07[0]}</td>
			</tr>
			<tr>
				<td>R1</td>
				<td>${R07[1]}</td>
			</tr>
			<tr>
				<td>R2</td>
				<td>${R07[2]}</td>
			</tr>
			<tr>
				<td>R3</td>
				<td>${R07[3]}</td>
			</tr>
			<tr>
				<td>R4</td>
				<td>${R07[4]}</td>
			</tr>
			<tr>
				<td>R5</td>
				<td>${R07[5]}</td>
			</tr>
			<tr>
				<td>R6</td>
				<td>${R07[6]}</td>
			</tr>
			<tr>
				<td>R7</td>
				<td>${R07[7]}</td>
			</tr>
		</tbody>
	</table>`;
		return registers;
//	if (ShowHideState){
//		document.getElementById("demo").innerHTML = '';
//		ShowHideState= !ShowHideState;
//	}
//	else {
//		document.getElementById("demo").innerHTML = registers;
//		ShowHideState= !ShowHideState;
//	}
}

function showFlags(){
	const div = document.getElementsByTagName("div")[1];

	const flags = `<table>
		<tbody>
			<tr>
				<th>Power</th>
				<th>Prgm</th>
				<th>Error</th>
				<th>New Num</th>
				<th>LastX</th>
				<th>Sci</th>
				<th>Eng</th>
				<th>Fix</th>
				<th>Deg</th>
				<th>Rad</th>
				<th>Grad</th>
				<th>f</th>
				<th>g</th>
				<th>Sto</th>
				<th>RCL</th>
				<th>Goto</th>
				<th>R/S</th>
				<th>Dec</th>
				<th>EEX</th>
				<th>E+</th>
			</tr>
			<tr>
				<td>${FlagArray[0]}</td>
				<td>${FlagArray[1]}</td>
				<td>${FlagArray[2]}</td>
				<td>${FlagArray[3]}</td>
				<td>${FlagArray[4]}</td>
				<td>${FlagArray[5]}</td>
				<td>${FlagArray[6]}</td>
				<td>${FlagArray[7]}</td>
				<td>${FlagArray[8]}</td>
				<td>${FlagArray[9]}</td>
				<td>${FlagArray[10]}</td>
				<td>${FlagArray[11]}</td>
				<td>${FlagArray[12]}</td>
				<td>${FlagArray[13]}</td>
				<td>${FlagArray[14]}</td>
				<td>${FlagArray[15]}</td>
				<td>${FlagArray[16]}</td>
				<td>${FlagArray[17]}</td>
				<td>${FlagArray[18]}</td>
				<td>${FlagArray[18]}</td>
			</tr>
		</tbody>
	</table>
	<br/>
	<table>
		<tbody>
			<tr>
				<th>Stack Pos</th>
				<th>Value</th>
			</tr>
			<tr>
				<td>X</td>
				<td>${X}</td>
			</tr>
			<tr>
				<td>Y</td>
				<td>${Y}</td>
			</tr>
			<tr>
				<td>Z</td>
				<td>${Z}</td>
			</tr>
			<tr>
				<td>T</td>
				<td>${T}</td>
			</tr>
			<tr>
				<td>LastX</td>
				<td>${LastX}</td>
			</tr>
		</tbody>
	</table>
	<br/>
	<table>
		<body>
			<tr>
				<th>Register</th>
				<th>Value</th>
			</tr>
			<tr>
				<td>R0</td>
				<td>${R07[0]}</td>
			</tr>
			<tr>
				<td>R1</td>
				<td>${R07[1]}</td>
			</tr>
			<tr>
				<td>R2</td>
				<td>${R07[2]}</td>
			</tr>
			<tr>
				<td>R3</td>
				<td>${R07[3]}</td>
			</tr>
			<tr>
				<td>R4</td>
				<td>${R07[4]}</td>
			</tr>
			<tr>
				<td>R5</td>
				<td>${R07[5]}</td>
			</tr>
			<tr>
				<td>R6</td>
				<td>${R07[6]}</td>
			</tr>
			<tr>
				<td>R7</td>
				<td>${R07[7]}</td>
			</tr>
		</body>
	</table>`
	
	if (ShowHideState){
		div.innerHTML = '';
		ShowHideState= !ShowHideState;
	}
	else {
		div.innerHTML = flags;
		ShowHideState= !ShowHideState;
	}
}

function findBtnFmClk(x,y)
{
	const KEY_HT = 31;
	const KEY_WN = 35;
	const KEY_WM = 40;
	const KEY_WW = 83;
	
	const PGRM_RUNX = 200;
	const ON_OFFX = 88;
	const PGRM_RUNY = 118;
	const ON_OFFY = 118;
	const PGRM_RUNW = 36;
	const ON_OFFW = 36;
	const PGRM_RUNH = 14;
	const ON_OFFH = 14;

	const FXN_KEY_RECT_BEGX = 49;
	const FXN_KEY_RECT_ENDX = 266;	// 231 + 35
	const FXN_KEY_RECT_BEGY = 162;
	const FXN_KEY_RECT_ENDY = 300;	// 259 + 31

	const KEY_PAD_RECT_BegX = 49;
	const KEY_PAD_RECT_ENDX = 275;	// 225 + 40
	const KEY_PAD_RECT_BegY = 323;
	const KEY_PAD_RECT_ENDY = 515;	// 474 + 31
	
	let rowCol = '00';

	if (PGRM_RUNY<=y && y<=PGRM_RUNY + PGRM_RUNH)	// power or pgrm
	{
		if (ON_OFFX<=x && x<=ON_OFFX + ON_OFFW) {rowCol = '01';}
		if (PGRM_RUNX<=x && x<=PGRM_RUNX + PGRM_RUNW) {rowCol = '02';}
	}
	else if (FXN_KEY_RECT_BEGY<=y && y<=FXN_KEY_RECT_ENDY)	// function key rectangle
	{
		if (y<=FXN_KEY_RECT_BEGY + KEY_HT)	// first row of fxn keys
		{
			if (FXN_KEY_RECT_BEGX<=x && x<=FXN_KEY_RECT_BEGX + KEY_WN) {rowCol = '11';}
			else if (97<=x && x<=97+KEY_WN) {rowCol = '12';}
			else if (145<=x && x<=145+KEY_WN) {rowCol = '13';}
			else if (192<=x && x<=192+KEY_WN) {rowCol = '14';}
			else if (241<=x && x<=241+KEY_WN) {rowCol = '15';}
		}
		else if (216<=y && y<=216+KEY_HT)	// second row of function keys
		{
			if (FXN_KEY_RECT_BEGX<=x && x<=FXN_KEY_RECT_BEGX + KEY_WN) {rowCol = '21';}
			else if (97<=x && x<=97+KEY_WN) {rowCol = '22';}
			else if (145<=x && x<=145+KEY_WN) {rowCol = '23';}
			else if (192<=x && x<=192+KEY_WN) {rowCol = '24';}
			else if (241<=x && x<=241+KEY_WN) {rowCol = '25';}
		}
		else if (269<=y && y<=269+KEY_HT)	// third row of function keys
		{
			if (FXN_KEY_RECT_BEGX<=x && x<=FXN_KEY_RECT_BEGX + KEY_WW) {rowCol = '31';}
			else if (145<=x && x<=145+KEY_WN) {rowCol = '32';}
			else if (192<=x && x<=192+KEY_WN) {rowCol = '33';}
			else if (241<=x && x<=241+KEY_WN) {rowCol = '34';}
		}
	}
	else if (KEY_PAD_RECT_BegY<=y && y<=KEY_PAD_RECT_ENDY)	// keypad rectangle
	{
		if (y<=KEY_PAD_RECT_BegY + KEY_HT)	// first row
		{
			if (KEY_PAD_RECT_BegX<=x && x<=KEY_PAD_RECT_BegX + KEY_WN) {rowCol = '41';}
			else if (108<=x && x<=108 + KEY_WM) {rowCol = '42';}
			else if (172<=x && x<=172 + KEY_WM) {rowCol = '43';}
			else if (235<=x && x<=235 + KEY_WM) {rowCol = '44';}
		}
		else if (376<=y && y<=376 + KEY_HT)	// second row
		{
			if (KEY_PAD_RECT_BegX<=x && x<=KEY_PAD_RECT_BegX + KEY_WN) {rowCol = '51';}
			else if (108<=x && x<=108 + KEY_WM) {rowCol = '52';}
			else if (172<=x && x<=172 + KEY_WM) {rowCol = '53';}
			else if (235<=x && x<=235 + KEY_WM) {rowCol = '54';}
		}
		else if (430<=y && y<=430 + KEY_HT)	// third row
		{
			if (KEY_PAD_RECT_BegX<=x && x<=KEY_PAD_RECT_BegX + KEY_WN) {rowCol = '61';}
			else if (108<=x && x<=108 + KEY_WM) {rowCol = '62';}
			else if (172<=x && x<=172 + KEY_WM) {rowCol = '63';}
			else if (235<=x && x<=235 + KEY_WM) {rowCol = '64';}
		}
		else if (484<=y && y<=483 + KEY_HT)	// fourth row
		{
			if (KEY_PAD_RECT_BegX<=x && x<=KEY_PAD_RECT_BegX + KEY_WN) {rowCol = '71';}
			else if (108<=x && x<=108 + KEY_WM) {rowCol = '72';}
			else if (172<=x && x<=172 + KEY_WM) {rowCol = '73';}
			else if (235<=x && x<=235 + KEY_WM) {rowCol = '74';}
		}
	}
	return rowCol;
}

function errorCond(warning) {
	alert(warning);
}

function twoNumStkShft(){				// takes care of stack after two number math function
	[Y,Z] = [Z,T];
}

function pushX(num){
	[X,Y,Z,T] = [num,X,Y,Z];
}

// Plan to rewrite the following to display numbers formatted like the HP-25.
// Initially shows two decimals, so 0 is shown as 0.00.
// Have a global for the number of significant figures: NumDecimals.
// It is initialized to two displayed decimals.
// Need to implement three different number formats, fixed, sci, and eng.
// Ideally this function will also display any error messages appropriately.
// Longer term goal will be to display data via old fashioned parts of an "8".
// In the short term will fake this with an appropriate font.
// Downloaded Digital-7 Italic font and will see if that fits the bill (in red!)
// A flag is needed during digital accumulation as the display is what has been 
// entered, not X. Or a true/false parameter indicating data accumulation.

// Maximum 10 digit number in fixed mode with room for the sign even when positive.
// Decimal point does not take up a "space", but is situated close to the previous num.
// Fixed can display from 0 to 9 decimals. Ten is maximum number of digits displayed in 
// fixed format, 8 in sci with 7 after the decimal. One can key in SCI 8 or 9, but 
// the rounding is lost in the display of 7 digits after the decimal.
// Eng is sci, but only uses exponents that are multiples of 3. Number keyed in 
// determines how many digits are displayed after the first three, eg 0->3 & 1->4.
// Also need to ensure that if the number is too small or large to switch from fixed 
// to SCI 7 in order to show the desired number os significant digits.
// After an auto switch to sci 7, entering a new number or CLX causes auto shift back 
// to FIX n that was set before the auto shift to SCI 7.
// What number is too small varies based on the decimals shown in FIX. If it will look 
// like zero an automatic shift to SCI 7 happens.
// Numbers > 10^10 will cause an automatic shift to SCI 7.

function display(numStr){				// display the passed string of digits
	document.getElementById('display').value = numStr;
}

function round(num,dec){		// returns num rounded to the number of decimals
								// specified by dec
	const timesTen = Math.round(num * 10 ** dec);
	return timesTen / 10 ** dec;
}

function getExp(fraction){				// finds the number of 10 factors required to increase
	let counter = 0;					// a number to greater then 1
	let posFrac = Math.abs(fraction);
	while (posFrac < 1){
		posFrac = 10 * posFrac;
		counter++;
	}
	return counter;
}

function pad(numStr){								// takes a positive argument
	let arrOfStrs = ["",""];
	let expSign = "";
	if (numStr.includes('+')){
		arrOfStrs = numStr.split('e+');					// now have array [1.123,2]
		expSign = " ";
	}
	else{													// numStr must be negative
		arrOfStrs = numStr.split('e-');
		expSign = "-";
	}
	const lenMan = arrOfStrs[0].length;				// includes int and .
	const lenExp = arrOfStrs[1].length;
	if (lenExp == 1){
		arrOfStrs[1] = '0' + arrOfStrs[1];
	}															// add 0 if needed
	if (lenMan < 10){
		arrOfStrs[0] = `${arrOfStrs[0]}${" ".repeat(15 - lenMan)}`;	// add spaces
	}
	return `${arrOfStrs[0]}${expSign}${arrOfStrs[1]}`;	// returns a string
}

function padEng(numStr) {
	const padding = " ".repeat(15 - NumDecimals - 4);
	if (NumDecimals == 6) 
	{
		padding = padding + " "
	}
	if (NumDecimals == 7) 
	{
		padding = padding + "  "
	}
	return `${padding}${numStr}`;
}

function dispFix(num){
	const dec = NumDecimals;
	let numStr = "";
	if (num > 10 ** 10){					// upper limit for numbers in FIX notation
		numStr = dispSci(num,7);			// auto switch to SCI 7
	}
	else if (num != 0 && Math.abs(num) < 1 && getExp(num) > dec){	// lower limit for numbers in FIX notation
		numStr = dispSci(num,7);			// auto switch to SCI 7
	}
	else {
		numStr = new Number(num).toFixed(dec);	// get a string
		if (num >= 0){							// if positive add space up front
			numStr = " " + numStr;
		}
	}
	return numStr;
}

function dispSci(num, decNum = NumDecimals){	// takes a number & optional num of decimals as arguments
	let strNum = "";
	let tempNum = num;
	if (num < 0){tempNum = Math.abs(num)}				
	strNum = tempNum.toExponential(decNum)		// now have 1.00e+1

	strNum = pad(strNum);						// adds spaces between mantissa and exp
	if (num >= 0){
		strNum = " " + strNum;					// add a space for sign
	}
	else {
		strNum = "-" + strNum;
	}
	return strNum;
}

function shiftTen (strNum) {		// shifts dec to right in str representation of num
	const strNumArr = strNum.split('.');
	return `${strNumArr[0]}${strNumArr[1].slice(0,1)}.${strNumArr[1].slice(1)}`
}

function dispEng(num) {
	const strNum = dispSci(num,7);			// now have num in format +x.xxxxxxx+yy
											// returned string is 13 chars
	let theNum = strNum.substring(0,10);	// assuming substring is inclusive
	const theExp = strNum.substring(10);
	const intExp = parseInt(theExp);
	let newExp = intExp;
	if (intExp % 3 == 0) {
		// do nothing
	} else if ((intExp - 1) % 3 == 0) {
		theNum = shiftTen(theNum);	// swap decimal and following char
		newExp = intExp - 1;
	} else if ((intExp - 2) % 3 == 0) {
		theNum = shiftTen(theNum);	// move dec two chars
		theNum = shiftTen(theNum);
		newExp = intExp - 2;
	}
	const finalNum = theNum.substring(0,5 + NumDecimals);
	let exponent = newExp.toString();
	if (newExp >= 0) {
		if (exponent.length == 1) {			// positive single digit exponent
			exponent = " 0" + exponent;
		}
	}
	else {
		if (exponent.length == 2) {			// negative single digit exponent
			exponent = "-0" + Math.abs(newExp).toString();
		}
	}
	exponent = padEng(exponent);
	
	return `${finalNum}${exponent}`;
}

function recall(digit){						// put register into X and raise stack
	if (getFlag('enter') || getFlag('clx') || getFlag('sigPlus')){
		X = R07[digit];						// don't push onto stack just replace X
		if (getFlag('enter')) { setFlag('enter'); }
		if (getFlag('clx')) { setFlag('clx'); }
		if (getFlag('sigPlus')) { setFlag('sigPlus'); }
	}
	else {
		pushX(R07[digit]);
	}
	if (getFlag('eex')) {
		setFlag('eex');
	}
	if (getFlag('eex')) { setFlag('eex'); }
	if (!getFlag('nPushX')) { setFlag('nPushX') }
	updateDisp(false);
}

function store(digit){
	if (storeFxn == ''){				// no math fxn selected prior to register number
		R07[digit] = X;					// store X in register specified
	}
	else {								// a math fxn was selected prior to reg number
		switch (storeFxn){
			case 'add':					// need to check for overflow > 9.999999999E99
				R07[digit] = R07[digit] + X;
				break;
			case 'subtract':
				R07[digit] = R07[digit] - X;
				break;
			case 'multiply':			// need to check for overflow > 9.999999999E99
				R07[digit] = R07[digit] * X;
				break;
			case 'divide':
				R07[digit] = R07[digit] / X;
				break;
		}
		storeFxn = '';
	}
	if (getFlag('eex')) { setFlag('eex'); }
}

function collectData(digit)
{										// need to trap register number or set sigfigs
	if (getFlag('sto')) {				// need to store a number
		store(digit,"");
		setFlag('sto');
		DataAccum.clearData();
		if (!getFlag('nPushX')) { setFlag('nPushX'); }
	}
	else if (getFlag('rcl')) {			// need to recall a number
		recall(digit);
		setFlag('rcl');
		DataAccum.clearData();
//		if (!getFlag('nPushX')) { setFlag('nPushX'); }
	}
	else if (getFlag('dec')) {			// need to set sigfigs
		NumDecimals = parseInt(digit);
		setFlag('dec');					// reset flag to false
		updateDisp(false);
	}
	else if (getFlag('eex')) {			// capture digits in exponent
		DataAccum.setExp(digit);
		updateDisp(true);
	}
	else {
		let decimal = digit;
		if ((decimal == '.') && DataAccum.getMantissa() == '') {
			decimal = '0.'
		}
		DataAccum.setMantissa(decimal);
		updateDisp(true);
	}
}

function power(){
	if (getFlag('power')){									// power was on
		setFlag('power');									// set flag to off
		document.getElementById("display").value = '';		// blank the display
		initStack();
		initFlagArray();
		initReg();
		DataAccum.clearData();	// used it so now clear it
		
	}
	else{													// power was off
		initFlagArray();									// initialize globals
		initNumDecimals();
		initStack();
		initReg();
		initPrgmMem();
		setFlag('power');									// set flag to on
		setFlag('fix');										// default display
		setFlag('deg');										// default trig
		setFlag('nPushX');									// ready for num entry
		X = 0;
		updateDisp(false);
	}
}

function prefix(fg){
	if (fg === 'f'){
		setFlag('f');
		const code = '14';
	}
	else{								// must be g
		setFlag('g');
		const code = '15';
	}
	if (getFlag('1')){					// record as prgm step
		PrgmMem[PrgmPos] = code			// but do not advance PrgmPos
	}
}

function calcMean() {
	if (R07[3] <= 0){
		errorCond("Must have two or more samples");
	}
	else{							// calculate the mean using R3 & R7
		X = R07[7] / R07[3];		// sum of entries over number of entries
		setFlag('nPushX');
		if (getFlag('eex')) {
			setFlag('eex');
		}
		updateDisp(false);
	}
}

function percentage() {				// not twoNumFunc() as Y is not changed
	// LastX = X;					// no lastX for percent
	X = Y * X / 100;				// X replaced; Y stays unchanged
	DataAccum.clearData();
	setFlag('nPushX');
	if (getFlag('eex')) {
		setFlag('eex');
	}
	updateDisp(false);
}

function swapXY(){					// swap X and Y registers
	[X,Y] = [Y,X];					// destructuring to the rescue
	setFlag('nPushX');
	if (getFlag('eex')) {
		setFlag('eex');
	}
	updateDisp(false);
}

function stdDev() {
	if (R07[3] <= 1) {
		errorCond("Must have two or more samples");
	}
	else {
		X = Math.sqrt((R07[6] - R07[7]*R07[7]/R07[3])/(R07[3] - 1));
		setFlag('nPushX');
		if (getFlag('eex')) {
			setFlag('eex');
		}
		updateDisp(false);				// sqrt((R7 - R6*R6/R3)/(R3 - 1))
	}
}

function oneNumFunc(func) {		// func is str representing the function called
// before calling func need to check newNum and put accumulating number into X
	DataAccum.clearData();	// used it so now clear it
	if (!getFlag('nPushX')) {
		setFlag('nPushX');
	}
	if (getFlag('eex')) {
		setFlag('eex');
	}
	LastX = X;
	switch (func)
	{
		case '1OverX':
			 X = oneOverX(X);
			break;
		case 'frac':
			X = frac(X);
			break;
		case 'int':
			X = intPart(X);
			break;
		case 'sqrt':
			X = sqrt(X);
			break;
		case 'square':
			X = square(X);
			break;
		case 'absVal':
			X = absVal(X);
			break;
		case 'natLog':
			X = natLog(X);
			break;
		case 'eToX':
			X = eToX(X);
			break;
		case 'log':
			X = log(X);
			break;
		case 'tenToX':
			X = tenToX(X);
			break;
		case 'hms':
			X = hms(X);
			break;
		case 'decFmHMS':
			X = decFmHMS(X);
			break;
		case 'sin':
			X = trig('sin', X, false);
			break;
		case 'cos':
			X = trig('cos', X, false);
			break;
		case 'tan':
			X = trig('tan', X, false);
			break;
		case 'arcsin':
			X = trig('sin', X, true);
			break;
		case 'arccos':
			X = trig('cos', X, true);
			break;
		case 'arctan':
			X = trig('tan', X, true);
			break;
	}
	
	function oneOverX(num) {		// NEED TO REDO ERROR WITH FLAG AND COMMENT STORAGE
		if (num === 0) {
			errorCond("Can't divide by zero");
		}
		else {
			return 1 / num;						// 1/X
		}
	}
	
	function natLog(num){
		if (num <= 0){					// error
			errorCond("Can't take ln of negative number or 0");
		}
		else {
			return Math.log(num);
		}
	}

	function eToX(num){
		return Math.exp(num);
	}

	function log(num){
		if (num <= 0){					// error
			errorCond("Can't take log of negative number or 0");
		}
		else {
			return Math.log(num)/Math.log(10);
		}
	}

	function tenToX(num){
		return 10 ** num;
	}

	function frac(num) {				// returns decimal part of real number
		return num - Math.floor(num);
	}

	function intPart(num){			// returns integer part of real number
		return Math.floor(num);
	}
	
	function sqrt(num) {
		if (num < 0){
			errorCond("Can't take square root of negative number");
		}
		else{
			return Math.sqrt(num);
		}
	}
	
	function square(num) {
		const sqrd = num * num;
		if (sqrd > 9.9999999e99) {
			errorCond("Result is too large for the HP-25")
		}
		else {
			return sqrd;
		}
	}
	
	function absVal(num) {
		return Math.abs(num);
	}

	function hms(num){
		const hours = Math.floor(num);
		let temp = 60 * frac(num);
		let minutes = Math.floor(temp);
		let seconds = frac(temp) * 60;
		return hours + minutes/100 + seconds/10000;
	}

	function decFmHMS(num){
		const hours = Math.floor(num);
		let temp = 100 * frac(num);
		const mins = Math.floor(temp);
		let secs = 100 * frac(temp);
		return hours + (secs/60 + mins)/60;
	}

// so if getFlag('rad') then do nothing
// if deg convert to radians
// if grad convert to radians
	function degConv(num,notInv){			// converts grads and degrees to radians
		if (notInv){						// convert to degrees before calc if needed
			if (getFlag('rad')){
				// return num*2*Math.PI/360;	do nothing here
			}
			else if (getFlag('grad')){		// convert to radians
				return num*Math.PI/200;
			}
			else{							// convert to radians
				return num*Math.PI/180;
			}
		}
		else{								// converting to degrees or grads after calc
			if (getFlag('rad')){
				return num;					// do nothing here as answer is already in rads
			}
			else if (getFlag('grad')){		// convert radians to grads
				return num*200/Math.PI;
			}
			else{							// convert radians to degrees
				return num*180/Math.PI;
			}
		}
	}

	function trig(func,num,inv){			// returns answer dependent on deg/rad/grad
		if (inv){							// an inverse trig function
			switch (func){
				case 'sin':
					if (Math.abs(num) < 1){
						return degConv(Math.asin(num),false);
					}
					else{
						errorCond("Number outside the range -1 - 1");
					}
					break;
				case 'cos':
					if (Math.abs(num) < 1){
						return  degConv(Math.acos(num),false);
					}
					else{
						errorCond("Number outside the range -1 - 1");
					}
					break;
				case 'tan':
					return  degConv(Math.atan(num),false);
					break;
			}
		
		}
		else{
			const deg = degConv(num,true);
			switch (func)
			{
				case 'sin':
					return Math.sin(deg);
					break;
				case 'cos':
					return Math.cos(deg);
					break;
				case 'tan':
					return Math.tan(deg);
					break;
			}
		}
	}
	updateDisp(false);
}


function rollDown(){
	[X,Y,Z,T] = [Y,Z,T,X];			// destructuring to the rescue
	if (getFlag('eex')) {
		setFlag('eex');
	}
	if (!getFlag('nPushX')) {
		setFlag('nPushX');
	}
	DataAccum.clearData();
	updateDisp(false);
}

function sigmaPlus() {					// number entry is followed by enter prior to sigP
	if (getFlag('f')) {					// sigma -
		setFlag('f');
		R07[3]--;						
		R07[4] = R07[4] - Y;
		R07[5] = R07[5] - X * Y;
		R07[6] = R07[6] - X * X;
		R07[7] = R07[7] - X;
		// LastX = X;					// no LastX saves in sig plus or minus
		X = R07[3];
	}
	else if (getFlag('g')){				// no g function on this key
		setFlag('g');
	}
	else {								// use contents of X & Y registers
		R07[3]++;						// count of entries
		R07[4] = R07[4] + Y;			// sum of y values
		R07[5] = R07[5] + X * Y;		// sum of x*y values
		R07[6] = R07[6] + X * X;		// sum of squares of x values
		R07[7] = R07[7] + X;			// sum of x values
		X = R07[3];
	}
	setFlag('sigPlus');				// not needed here, but return to false
	if (getFlag('eex')) {
		setFlag('eex');
	}
	updateDisp(false);
	DataAccum.clearData();			// used it so now clear it
}

function numKey(keyPressed){	// In an attempt to simplify the code for number key 
	if (getFlag('f')){			// presses the logic is moved to this numKey function.
		setFlag('f');			// The meat of execution is passed to numKeyF() or 
		funcKeyF(keyPressed);	// numKeyG().
	}
	else if (getFlag('g')){
		setFlag('g');
		funcKeyG(keyPressed);
	}
	else{
		if (getFlag('nPushX')) {
			pushX(X);
			setFlag('nPushX');
		}
		collectData(keyPressed);
	}
}

function polarToRect(magnitude, phi) {
	let radPhi = 0;
	if (getFlag('deg')) {			// convert to radians
		radPhi = phi * Math.PI/180;
	}
	else if (getFlag('rad')) {		// phi in radians
		radPhi = phi;
	}
	else if (getFlag('grad')) {		// convert to radians
		radPhi = phi * Math.PI/200;
	}
	const x = magnitude * Math.cos(radPhi);
	const y = magnitude * Math.sin(radPhi);
	const resultArr = [x, y];
	return resultArr;
}

function polToRect(){			// not using twoNunFunc() as twoNumStkShft not needed
	const coordArr = polarToRect(X,Y);	// array with two coordinates is returned
	X = coordArr[0];
	Y = coordArr[1];
	LastX = X;
	if (getFlag('eex')) {
		setFlag('eex');
	}
	setFlag('nPushX');
	DataAccum.clearData();	// used it so now clear it
	updateDisp(false);
}

function rectToPolar(a,b) {
	const magnitude = Math.sqrt(a*a + b*b);
	let phi = 0;
	let resultArr = [0,0];
	if (magnitude == 0) {
		errorCond("Either X or Y must be non-zero.")
	}
	if (b >= 0) {							// in radians
		phi = Math.acos(a/magnitude);
	}
	else if (b < 0) {
		phi = -Math.acos(a/magnitude);
	}
	resultArr[0] = magnitude;
	if (getFlag('deg')) {		// in degrees mode
		resultArr[1] = phi * 180/Math.PI;
	}
	else if (getFlag('grad')) {		// in grad mode
		resultArr[1] = phi * 200/Math.PI;
	}
	else if (getFlag('rad')) {		// in radians mode
		resultArr[1] = phi;
	}
	return resultArr;
}

function rectToPol(){
	const coordArr = rectToPolar(X,Y);
	X = coordArr[0];
	Y = coordArr[1];
	LastX = X;
	if (getFlag('eex')) {
		setFlag('eex');
	}
	setFlag('nPushX');
	DataAccum.clearData();	// used it so now clear it
	updateDisp(false);
}

function lastX(){		// note that LastX is only implemented once a number button 
	pushX(LastX);		// has been pushed, so the triggers for this function need 
	if (getFlag('eex')) {
		setFlag('eex');
	}
	DataAccum.clearData();	// used it so now clear it
	updateDisp(false);	// need to be rewritten at some point
}

function pi() {
	DataAccum.clearData();	// used it so now clear it
	// LastX = X;	for some reason pi does not save X in LastX
	pushX(Math.PI);
	setFlag('nPushX');
	if (getFlag('eex')) {
		setFlag('eex');
	}
	updateDisp(false);
}

function funcKeyF(keyPressed){
	switch (keyPressed)
	{
		case 'minus':			// x < y
			break;
		case 'plus':			// x >= y
			break;
		case 'times':			// x != y
			break;
		case 'divide':			// x = y
			break;
	}
	setFlag('f');				// turn f flag off
}

function funcKeyG(keyPressed){
	switch (keyPressed)
	{
		case 'minus':			// x < 0
			break;
		case 'plus':			// x >= 0
			break;
		case 'times':			// x != 0
			break;
		case 'divide':			// x = 0
			break;
	}
	setFlag('g');				// turn g flag off
}

function twoNumFunc(keyPressed){
// 	if (getFlag('f')){
// 		setFlag('f');
// 		funcKeyF(keyPressed);
// 	}
// 	else if (getFlag('g')){
// 		setFlag('g');
// 		funcKeyG(keyPressed);
// 	}
//	else{
	if (getFlag('eex')) {
		setFlag('eex');
	}
	DataAccum.clearData();			// used it so now clear it
	LastX = X;
	if (getFlag('eex')) {
		setFlag('eex');
	}
	switch (keyPressed)
	{
		case 'minus':
			minus();
			break;
		case 'plus':
			plus();
			break;
		case 'times':
			times();
			break;
		case 'divide':
			divide();
			break;
		case 'yToX':
			yToX();
			break;
	}
	twoNumStkShft();
	if (!getFlag('nPushX')) { setFlag('nPushX'); }
	updateDisp(false);
//	}
	function minus(){
		X = Y - X;
	}

	function plus(){
		X = Y + X;			// need overflow check
	}

	function times(){
		X = Y * X;			// need overflow check
	}

	function divide(){
		if (X != 0){
			X = Y / X;
		}
		else{
			errorCond("Can't divide by zero");
		}
	}

	function yToX(){
		if (Y <= 0){
			errorCond("Can't raise negative number or 0 to a power");
		}
		else {
			X = Y ** X;
		}
	}

}

function enter(){
	if (getFlag('f')){					// Clear Prefix
		setFlag('f');					// also clear STO, RCL, & GOTO
		if (getFlag('g')){setFlag('g')};
		if (getFlag('sto')){setFlag('sto')};
		if (getFlag('rcl')){setFlag('rcl')};
		if (getFlag('goto')){setFlag('goto')};
	}
	else if (getFlag('g')){				// unused
		
	}
	else{
		if (getFlag('eex')) {
			setFlag('eex');
		}
		pushX(X);						// don't want to set flag nPushX as we just pushed
		DataAccum.clearData();			// used it so now clear it
		if (getFlag('nPushX')) { setFlag('nPushX'); }
		updateDisp(false);
	}
}

function clearX(){
	X = 0.0;						// don't want to set flag nPushX as we just pushed
	if (getFlag('eex')) {
		setFlag('eex');
	}
	DataAccum.clearData();
	updateDisp(false);
}

function setFormat(format){			// set all flags to false
	if (getFlag("fix")){
		setFlag("fix");
	}
	if (getFlag("sci")){
		setFlag("sci");
	}
	if (getFlag("eng")){
		setFlag("eng");
	}
	setFlag(format);			// then set desired flag to true
	setFlag('dec');
	setFlag("f");		
}


function clearStk() {
	initStack();
	setFlag('nPuxhX');
	clearX();
}

function clearReg() {
	initReg();
}

function clearPgrm() {
	initPgrmMem();
}

function clearPrefix() {
	if (getFlag('f')) {
		setFlag('f');
	}
	if (getFlag('g')) {
		setFlag('g');
	}
}

function chSign()
{
	if (getFlag('eex')) {
		const sign = (DataAccum.getExpSign() == " ") ? "-": " ";
		if (getFlag('nPushX')) { setFlag('nPushX'); }
		DataAccum.setExpSign(sign);					// need to change exponent sign
		updateDisp(true);
	}
	else {
		if (X!== 0) {
			X = -X;
			updateDisp(false);
		}
		else {
			const sign = (DataAccum.getSign() == " ") ? "-": " ";
			setFlag('nPushX');
			DataAccum.setSign(sign);					// need to change mantissa sign
			updateDisp(true);
		}
	}
}

function btnClicked(btn)
{
	if (btn == '01'){
		power();
	}
	else{
		if (getFlag('power')){			// power is on so buttons work
			switch (btn)
			{
				case "02":	// prgm
					break;
				case "11":	// SST, Fix
					if (getFlag("f")){
						setFormat('fix');	//don't want to push X when changing format
						if (getFlag('nPushX')) {setFlag('nPushX')};
					}
					break;
				case "12":	// BST, Sci
					if (getFlag("f")){
						setFormat('sci');
						if (getFlag('nPushX')) {setFlag('nPushX')};
					}
					break;
				case "13":	// GTO, Eng
					if (getFlag("f")){
						setFormat('eng');
						if (getFlag('nPushX')) {setFlag('nPushX')};
					}
					break;
				case "14":	// f
					prefix('f');
					break;
				case "15":	// g
					prefix('g');
					break;
				case "21":	// x<>y, Mean, %
					if (getFlag('f')) {
						calcMean();
						setFlag('f');
					}
					else if (getFlag('g')) {
						percentage();
						setFlag('g');
					}
					else {
						swapXY();
					}
					break;
				case "22":	// R down, Std dev, 1/x
					if (getFlag('f')) {
						stdDev();
						setFlag('f');
					}
					else if (getFlag('g')) {
						oneNumFunc('1OverX');
						setFlag('g');
					}
					else {
						rollDown();
					}
					break;
				case "23":	// STO
					setFlag('sto');		// need to handle register math
										// number entered STO or RCL is not shown
					break;
				case "24":	// RCL
					setFlag('rcl');		// causes stack to lift except after Enter, CLX, Sigma+
					break;
				case "25":				// Sigma +	// does Sigma - as well
					setFlag('sigPlus');	// not sure when to turn this flag off?
					sigmaPlus();		// will need to redo this for programming
					break;
				case "31":	// Enter, Clear Prefix
					if (getFlag('f')) {
						clearPrefix();
					}
					else {
						enter();
					}
					break;
				case "32":	// CHS, Clear Pgrm, Deg
					if (getFlag('f')) {
						initPgrmMem();
						setFlag('f');
					}
					else if (getFlag('g')) {	// set deg flag and false for rad/grad
						if (!getFlag('deg')) { setFlag('deg'); }
						if (getFlag('rad')) { setFlag('rad'); }
						if (getFlag('grad')) { setFlag('grad'); }
						setFlag('g');
					}
					else {
						chSign();
					}
					break;
				case "33":	// EEX, Clear Reg, Rad
					if (getFlag('f')) {
						clearReg();
						setFlag('f');
					}
					else if (getFlag('g')) {
						if (getFlag('deg')) { setFlag('deg'); }
						if (!getFlag('rad')) { setFlag('rad'); }
						if (getFlag('grad')) { setFlag('grad'); }
						setFlag('g');
					}
					else {
						setFlag('eex');
						DataAccum.setExp('0');
						updateDisp(true);
					}
					break;
				case "34":	// CLX, Clear Stack, Grad
					if (getFlag('f')) {
						clearStk();
						setFlag('f');
					}
					else if (getFlag('g')) {
						if (getFlag('deg')) { setFlag('deg'); }
						if (getFlag('rad')) { setFlag('rad'); }
						if (!getFlag('grad')) { setFlag('grad'); }
						setFlag('g');
					}
					else {
						clearX();
					}
					break;
				case "41":	// -, x<y, x<0
					if (getFlag('sto')){		// STO pushed prior to minus
						storeFxn = 'subtract';
					}
					else{
						if (getFlag('f')) {
							funcKeyF('minus');
						}
						else if (getFlag('g')) {
							funcKeyG('minus');
						}
						else {
							twoNumFunc('minus');
						}
					}
					break;
				case "42":	// 7, ln, e^x
					if (getFlag('f')) {
						oneNumFunc('natLog');
						setFlag('f');
					}
					else if (getFlag('g')) {
						oneNumFunc('eToX');
						setFlag('g');
					}
					else {
						numKey('7');
					}
					break;
				case "43":	// 8, log, 10^x
					if (getFlag('f')) {
						oneNumFunc('log');
						setFlag('f');
					}
					else if (getFlag('g')) {
						oneNumFunc('tenToX');
						setFlag('g');
					}
					else {
						numKey('8');
					}
					break;
				case "44":	// 9, ->R, ->P
					if (getFlag('f')) {
						polToRect();
						setFlag('f');
					}
					else if (getFlag('g')) {
						rectToPol();
						setFlag('g');
					}
					else {
						numKey('9');
					}
					break;
				case "51":	// +, x>=y, x>=0
					if (getFlag('sto')){		// STO pushed prior to plus
						storeFxn = 'add';
					}
					else{
						if (getFlag('f')) {
							funcKeyF('plus');
						}
						else if (getFlag('g')) {
							funcKeyG('plus');
						}
						else {
							twoNumFunc('plus');
						}
					}
					break;
				case "52":	// 4, sin, sin^(-1)
					if (getFlag('f')) {
						oneNumFunc('sin');
						setFlag('f');
					}
					else if (getFlag('g')) {
						oneNumFunc('arcsin');
						setFlag('g');
					}
					else {
						numKey('4');
					}
					break;
				case "53":	// 5, cos, cos^(-1)
					if (getFlag('f')) {
						oneNumFunc('cos');
						setFlag('f');
					}
					else if (getFlag('g')) {
						oneNumFunc('arccos');
						setFlag('g');
					}
					else {
						numKey('5');
					}
					break;
				case "54":	// 6, tan, tan^(-1)
					if (getFlag('f')) {
						oneNumFunc('tan');
						setFlag('f');
					}
					else if (getFlag('g')) {
						oneNumFunc('arctan');
						setFlag('g');
					}
					else {
						numKey('6');
					}
					break;
				case "61":	// *, x!=y, x!=0
					if (getFlag('sto')){		// STO pushed prior to times
						storeFxn = 'multiply';
					}
					else{
						if (getFlag('f')) {
							funcKeyF('times');
						}
						else if (getFlag('g')) {
							funcKeyG('times');
						}
						else {
							twoNumFunc('times');
						}
					}
					break;
				case "62":	// 1, int frac
					if (getFlag('f')) {
						oneNumFunc('int');
						setFlag('f');
					}
					else if (getFlag('g')) {
						oneNumFunc('frac');
						setFlag('g');
					}
					else {
						numKey('1');
					}
					break;
				case "63":	// 2, sqrt, x^2
					if (getFlag('f')) {
						oneNumFunc('sqrt');
						setFlag('f');
					}
					else if (getFlag('g')) {
						oneNumFunc('square');
						setFlag('g');
					}
					else {
						numKey('2');
					}
					break;
				case "64":	// 3, y^x, ABS
					if (getFlag('f')) {
						twoNumFunc('yToX');
						setFlag('f');
					}
					else if (getFlag('g')) {
						oneNumFunc('absVal');
						setFlag('g');			// set flag here to keep func clean
					}
					else {
						numKey('3');
					}
					break;
				case "71":	// /, x=y, x=0
					if (getFlag('sto')){		// STO pushed prior to divide
						storeFxn = 'divide';	// global to remember what to do with num
					}
					else{
						if (getFlag('f')) {
							funcKeyF('divide');
						}
						else if (getFlag('g')) {
							funcKeyG('divide');
						}
						else {
							twoNumFunc('divide');
						}
					}
					break;
				case "72":	// 0, ->H.MS, ->H
					if (getFlag('f'))  {
						oneNumFunc('hms');					// Changes decimal hrs (degs) to H.MM.SS
						setFlag('f');
					}
					else if (getFlag('g')) {
						oneNumFunc('decFmHMS');
						setFlag('g');
					}
					else {
						numKey('0');
					}
					break;
				case "73":	// ., LastX, pi
					if (getFlag('f'))  {
						lastX();					// replaces X with LastX
						setFlag('f');
					}
					else if (getFlag('g')) {
						pi();					// replaces X with pi
						setFlag('g');
					}
					else {
						numKey('.');
					}
					break;
				case "74":	// R/S, Pause, NOP
					break;
			}
		} // end of if getflag('power')
	} // end of else
}

function showCoords(event) {
    let cX = event.clientX;
    let sX = event.screenX;
    let cY = event.clientY;
    let sY = event.screenY;
    let coords1 = "client - X: " + cX + ", Y coords: " + cY;
    let coords2 = "screen - X: " + sX + ", Y coords: " + sY;
    let button = findBtnFmClk(cX,cY);						// button is array
    btnClicked(button);
    document.getElementById("demo").innerHTML = coords1 + "<br/>" + coords2 + "<br/>" + button + "<br/>" + showRegs();
	showRegs();
}

// -->

</script>

</head>
<body>

<div class="bg-img" onclick="showCoords(event)">


<br/><br/>

<form class="container">
	<input type="text" id="display" readOnly="True">
</form>


</div>
<div>
	<p id="demo"></p>
	<p id="demo1"></p>
</div>

<div id="divDemo" class="debug">

</div>


<footer>
	<p><a href="Math%20Calculators.html">Math Calculators</a></p>
	<p>John H. McDonald, III</p>
	<p>May 27, 2018</p>
</footer>

</body>
</html>